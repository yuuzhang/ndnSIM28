<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.body_foreground > .bold,.bold > .body_foreground, body.body_foreground > pre > .bold { color: #FFFFFF; font-weight: normal; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi41 { background-color: #aa0000; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 ...7\256\346\224\271\350\256\260\345\275\225.html" | 913 <span class="ansi32">+++++++++++++++++++++</span>
 NFD/daemon/fw/randomized-rounding-strategy.cpp     |  19 <span class="ansi32">+</span><span class="ansi31">-</span>
 NFD/daemon/mgmt/fib-manager.cpp                    |   7 <span class="ansi32">+</span><span class="ansi31">-</span>
 NFD/daemon/table/fib-entry.cpp                     |   7 <span class="ansi32">+</span><span class="ansi31">-</span>
 NFD/daemon/table/fib-nexthop.hpp                   |   9 <span class="ansi32">+</span><span class="ansi31">-</span>
 apps/ndn-producer.cpp                              |   5 <span class="ansi32">+</span><span class="ansi31">-</span>
 ...57\274\214\344\275\206\346\212\245\351\224\231" | 591 <span class="ansi32">+++++++++++++</span>
 ...46\230\257\344\270\200\346\240\267\347\232\204" | 330 <span class="ansi32">++++++++</span>
 diff.html                                          |   0
 examples/12Nodes-Iot-2.py                          | 278 <span class="ansi32">+++++++</span>
 examples/12Nodes-Iot.py                            | 278 <span class="ansi32">+++++++</span>
 examples/300Nodes-zhangyu-routing-2.py             | 288 <span class="ansi32">+++++++</span>
 examples/300Nodes-zhangyu-routing.py               | 288 <span class="ansi32">+++++++</span>
 examples/5Nodes-zhangyu-routing.py                 | 273 <span class="ansi32">++++++</span>
 examples/Fleischer.py                              | 184 <span class="ansi32">+++++</span>
 examples/mintreeMFP.py                             | 751 <span class="ansi32">+++++++++++++++++</span>
 examples/ndn-zhangyu-multipath.cpp                 |  26 <span class="ansi32">+</span><span class="ansi31">-</span>
 examples/zhangyu-learning.cpp                      | 459 <span class="ansi32">+++++++++++</span>
 helper/lfid/ndn-global-routing-helper-lfid.cpp     |   2 <span class="ansi32">+</span><span class="ansi31">-</span>
 helper/ndn-fib-helper.cpp                          |   6 <span class="ansi32">+</span><span class="ansi31">-</span>
 ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp    |   3 <span class="ansi32">+</span><span class="ansi31">-</span>
 utils/topology/annotated-topology-reader.cpp       |   4 <span class="ansi32">+</span><span class="ansi31">-</span>
 22 files changed, 4693 insertions(+), 28 deletions(-)

<span class="ansi1">diff --git "a/2020_ndnSIM28_RandomizedRounding\344\273\243\347\240\201\344\277\256\346\224\271\350\256\260\345\275\225.html" "b/2020_ndnSIM28_RandomizedRounding\344\273\243\347\240\201\344\277\256\346\224\271\350\256\260\345\275\225.html"</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..3e99725</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ "b/2020_ndnSIM28_RandomizedRounding\344\273\243\347\240\201\344\277\256\346\224\271\350\256\260\345\275\225.html"</span>
<span class="ansi36">@@ -0,0 +1,913 @@</span>
<span class="ansi32">+</span><span class="ansi32">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;html&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;head&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;title&gt;&lt;/title&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;style type="text/css"&gt;</span>
<span class="ansi32">+</span><span class="ansi32">.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }</span>
<span class="ansi32">+</span><span class="ansi32">.body_foreground { color: #AAAAAA; }</span>
<span class="ansi32">+</span><span class="ansi32">.body_background { background-color: #000000; }</span>
<span class="ansi32">+</span><span class="ansi32">.body_foreground &gt; .bold,.bold &gt; .body_foreground, body.body_foreground &gt; pre &gt; .bold { color: #FFFFFF; font-weight: normal; }</span>
<span class="ansi32">+</span><span class="ansi32">.inv_foreground { color: #000000; }</span>
<span class="ansi32">+</span><span class="ansi32">.inv_background { background-color: #AAAAAA; }</span>
<span class="ansi32">+</span><span class="ansi32">.ansi1 { font-weight: bold; }</span>
<span class="ansi32">+</span><span class="ansi32">.ansi31 { color: #aa0000; }</span>
<span class="ansi32">+</span><span class="ansi32">.ansi32 { color: #00aa00; }</span>
<span class="ansi32">+</span><span class="ansi32">.ansi36 { color: #00aaaa; }</span>
<span class="ansi32">+</span><span class="ansi32">.ansi41 { background-color: #aa0000; }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;/style&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;/head&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;body class="body_foreground body_background" style="font-size: normal;" &gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;pre class="ansi2html-content"&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/fw/randomized-rounding-strategy.cpp  |  35 &lt;span class="ansi32"&gt;++++&lt;/span&gt;&lt;span class="ansi31"&gt;-&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/fw/randomized-rounding-strategy.hpp  |  15 &lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi31"&gt;-&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/mgmt/fib-manager.cpp                 |   9 &lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi31"&gt;-&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/table/fib-entry.cpp                  |  18 &lt;span class="ansi32"&gt;+++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/table/fib-entry.hpp                  |   7 &lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/table/fib-nexthop.hpp                |  17 &lt;span class="ansi32"&gt;++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/table/fib.cpp                        |  12 &lt;span class="ansi32"&gt;++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> NFD/daemon/table/fib.hpp                        |   7 &lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> examples/ndn-zhangyu-multipath.cpp              | 197 &lt;span class="ansi32"&gt;++++++++++++++++++++++++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> examples/topologies/topo-load-balancer2.txt     |  52 &lt;span class="ansi32"&gt;+++++++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> helper/ndn-fib-helper.cpp                       |  72 &lt;span class="ansi32"&gt;+++++++++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> helper/ndn-fib-helper.hpp                       |  40 &lt;span class="ansi32"&gt;+++++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> helper/ndn-global-routing-helper.cpp            |  33 &lt;span class="ansi32"&gt;++++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> helper/ndn-global-routing-helper.hpp            |  15 &lt;span class="ansi32"&gt;++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> ndn-cxx/ndn-cxx/encoding/tlv-nfd.hpp            |   1 &lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> ndn-cxx/ndn-cxx/mgmt/nfd/control-command.cpp    |   8 &lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi31"&gt;-&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.cpp |  20 &lt;span class="ansi32"&gt;++&lt;/span&gt;&lt;span class="ansi31"&gt;-&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp |  34 &lt;span class="ansi32"&gt;++++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> 18 files changed, 579 insertions(+), 13 deletions(-)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/fw/randomized-rounding-strategy.cpp b/NFD/daemon/fw/randomized-rounding-strategy.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index c54767c..986ff53 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/fw/randomized-rounding-strategy.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/fw/randomized-rounding-strategy.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -43,11 +43,11 @@&lt;/span&gt; RandomizedRoundingStrategy::RandomizedRoundingStrategy(Forwarder&amp;amp; forwarder, con</span>
<span class="ansi32">+</span><span class="ansi32"> {</span>
<span class="ansi32">+</span><span class="ansi32">   ParsedInstanceName parsed = parseInstanceName(name);</span>
<span class="ansi32">+</span><span class="ansi32">   if (!parsed.parameters.empty()) {</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-    NDN_THROW(std::invalid_argument("RandomStrategy does not accept parameters"));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    NDN_THROW(std::invalid_argument("Randomized Rounding Strategy does not accept parameters"));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">   if (parsed.version &amp;amp;&amp;amp; *parsed.version != getStrategyName()[-1].toVersion()) {</span>
<span class="ansi32">+</span><span class="ansi32">     NDN_THROW(std::invalid_argument(</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-      "RandomStrategy does not support version " + to_string(*parsed.version)));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      "Randomized Rounding Strategy does not support version " + to_string(*parsed.version)));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">   this-&amp;gt;setInstanceName(makeInstanceName(name, getStrategyName()));</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -55,7 +55,7 @@&lt;/span&gt; RandomizedRoundingStrategy::RandomizedRoundingStrategy(Forwarder&amp;amp; forwarder, con</span>
<span class="ansi32">+</span><span class="ansi32"> const Name&amp;amp;</span>
<span class="ansi32">+</span><span class="ansi32"> RandomizedRoundingStrategy::getStrategyName()</span>
<span class="ansi32">+</span><span class="ansi32"> {</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-  static Name strategyName("/localhost/nfd/strategy/random/%FD%01");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  static Name strategyName("/localhost/nfd/strategy/randomized-rounding/%FD%01");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   return strategyName;</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -79,9 +79,34 @@&lt;/span&gt; RandomizedRoundingStrategy::afterReceiveInterest(const FaceEndpoint&amp;amp; ingress, co</span>
<span class="ansi32">+</span><span class="ansi32">     this-&amp;gt;rejectPendingInterest(pitEntry);</span>
<span class="ansi32">+</span><span class="ansi32">     return;</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // ZhangYu 2020-8-30&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  boost::random::uniform_01&amp;lt;boost::random::mt19937&amp;amp;&amp;gt; dist(m_randomGenerator);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //dist.reset();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //std::cout &amp;lt;&amp;lt; "ZhangYu 2018-3-25 randomValue: " &amp;lt;&amp;lt; dist() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  const uint64_t randomValue =std::round(dist() *1000000); //和 global-routing-help中的一样&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //std::cout &amp;lt;&amp;lt; "ZhangYu 2018-3-25 randomValue: " &amp;lt;&amp;lt; randomValue &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  uint64_t probabilitySum=0;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  fib::NextHopList::const_iterator selected;	//端口变量&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  uint64_t index=0;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  for(selected=nhs.begin(); selected !=nhs.end(); ++selected) {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  index=index+1;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  probabilitySum+=selected-&amp;gt;getProbability();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  //ZhangYu 2018-4-6这里是否加=应该影响不大，主要担心的是概率为0和1的记录，但都是小概率事件。&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  if(randomValue&amp;lt;=probabilitySum){&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  this-&amp;gt;sendInterest(pitEntry, FaceEndpoint(selected-&amp;gt;getFace(),0), interest);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  /*&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  std::cout &amp;lt;&amp;lt; "      ZhangYu 2018-2-1 afterReceiveInterest-- "&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;				&lt;span class="ansi32"&gt;  &amp;lt;&amp;lt; " face: " &amp;lt;&amp;lt; FaceEndpoint(selected-&amp;gt;getFace(),0)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;				&lt;span class="ansi32"&gt;  &amp;lt;&amp;lt; " cost: " &amp;lt;&amp;lt; selected-&amp;gt;getCost()&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;				&lt;span class="ansi32"&gt;  &amp;lt;&amp;lt; " probability: " &amp;lt;&amp;lt; selected-&amp;gt;getProbability() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-  std::shuffle(nhs.begin(), nhs.end(), ndn::random::getRandomNumberEngine());&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-  this-&amp;gt;sendInterest(pitEntry, FaceEndpoint(nhs.front().getFace(), 0), interest);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  std::cout &amp;lt;&amp;lt; "!!ZhangYu 2018-3-25, index:" &amp;lt;&amp;lt; index &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  return;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //std::shuffle(nhs.begin(), nhs.end(), ndn::random::getRandomNumberEngine());&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //this-&amp;gt;sendInterest(pitEntry, FaceEndpoint(nhs.front().getFace(), 0), interest);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32"> void</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/fw/randomized-rounding-strategy.hpp b/NFD/daemon/fw/randomized-rounding-strategy.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 1ee17fd..e5b65d4 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/fw/randomized-rounding-strategy.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/fw/randomized-rounding-strategy.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -30,14 +30,18 @@&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> #include "strategy.hpp"</span>
<span class="ansi32">+</span><span class="ansi32"> #include "process-nack-traits.hpp"</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/random.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/random/mersenne_twister.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "face/face.hpp"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "algorithm.hpp"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> namespace nfd {</span>
<span class="ansi32">+</span><span class="ansi32"> namespace fw {</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-/** \brief Randomly chooses a nexthop&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;- *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;/** \ZhangYu 2020-8-30,使用路由表提供的端口转发概率进行随机转发，可以实现 traffic split。&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * ndnSIM自带的多转发是多份副本，不是traffic split。&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">  * Sends an incoming interest to a random outgoing face,</span>
<span class="ansi32">+</span><span class="ansi32">  * excluding the incoming face.</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;- *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">  */</span>
<span class="ansi32">+</span><span class="ansi32"> class RandomizedRoundingStrategy : public Strategy</span>
<span class="ansi32">+</span><span class="ansi32">                      , public ProcessNackTraits&amp;lt;RandomizedRoundingStrategy&amp;gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -59,9 +63,12 @@&lt;/span&gt; public:</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32"> private:</span>
<span class="ansi32">+</span><span class="ansi32">   friend ProcessNackTraits&amp;lt;RandomizedRoundingStrategy&amp;gt;;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;protected:&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  boost::random::mt19937 m_randomGenerator;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> };</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32"> } // namespace fw</span>
<span class="ansi32">+</span><span class="ansi32"> } // namespace nfd</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-#endif // NFD_DAEMON_FW_RANDOMIZEDOUNDING_STRATEGY_HPP&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#endif // NFD_DAEMON_FW_RANDOMIZEDROUNDING_STRATEGY_HPP&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/mgmt/fib-manager.cpp b/NFD/daemon/mgmt/fib-manager.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index c048da5..98df452 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/mgmt/fib-manager.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/mgmt/fib-manager.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -61,6 +61,12 @@&lt;/span&gt; FibManager::addNextHop(const Name&amp;amp; topPrefix, const Interest&amp;amp; interest,</span>
<span class="ansi32">+</span><span class="ansi32">   const Name&amp;amp; prefix = parameters.getName();</span>
<span class="ansi32">+</span><span class="ansi32">   FaceId faceId = parameters.getFaceId();</span>
<span class="ansi32">+</span><span class="ansi32">   uint64_t cost = parameters.getCost();</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // ZhangYu 2020-8-30,2018-2-1&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  uint64_t probability=std::numeric_limits&amp;lt;uint64_t&amp;gt;::max();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  if(parameters.hasProbability()){&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  probability=parameters.getProbability();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  //std::cout &amp;lt;&amp;lt; "ZhangYu 2018-2-1 FibManager::addNexHop probability: " &amp;lt;&amp;lt; probability &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">   if (prefix.size() &amp;gt; Fib::getMaxDepth()) {</span>
<span class="ansi32">+</span><span class="ansi32">     NFD_LOG_DEBUG("fib/add-nexthop(" &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; faceId &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; cost &amp;lt;&amp;lt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -77,7 +83,8 @@&lt;/span&gt; FibManager::addNextHop(const Name&amp;amp; topPrefix, const Interest&amp;amp; interest,</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">   fib::Entry* entry = m_fib.insert(prefix).first;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-  m_fib.addOrUpdateNextHop(*entry, *face, cost);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // ZhangYu&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  m_fib.addOrUpdateNextHop(*entry, *face, cost, probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">   NFD_LOG_TRACE("fib/add-nexthop(" &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; faceId &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; cost &amp;lt;&amp;lt; "): OK");</span>
<span class="ansi32">+</span><span class="ansi32">   return done(ControlResponse(200, "Success").setBody(parameters.wireEncode()));</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/table/fib-entry.cpp b/NFD/daemon/table/fib-entry.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index ade4c9f..fb5610d 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/table/fib-entry.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/table/fib-entry.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -65,6 +65,24 @@&lt;/span&gt; Entry::addOrUpdateNextHop(Face&amp;amp; face, uint64_t cost)</span>
<span class="ansi32">+</span><span class="ansi32">   return std::make_pair(it, isNew);</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;//ZhangYu 2020-8-30,2018-1-30&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;std::pair&amp;lt;NextHopList::iterator, bool&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;Entry::addOrUpdateNextHop(Face&amp;amp; face, uint64_t cost, uint64_t probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  auto it = this-&amp;gt;findNextHop(face);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  bool isNew = false;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  if (it == m_nextHops.end()) {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;m_nextHops.emplace_back(face);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;it = std::prev(m_nextHops.end());&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;isNew = true;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  it-&amp;gt;setCost(cost);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  it-&amp;gt;setProbability(probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  this-&amp;gt;sortNextHops();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  return std::make_pair(it, isNew);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> bool</span>
<span class="ansi32">+</span><span class="ansi32"> Entry::removeNextHop(const Face&amp;amp; face)</span>
<span class="ansi32">+</span><span class="ansi32"> {</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/table/fib-entry.hpp b/NFD/daemon/table/fib-entry.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 7460eda..bb564ab 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/table/fib-entry.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/table/fib-entry.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -92,6 +92,13 @@&lt;/span&gt; private:</span>
<span class="ansi32">+</span><span class="ansi32">   std::pair&amp;lt;NextHopList::iterator, bool&amp;gt;</span>
<span class="ansi32">+</span><span class="ansi32">   addOrUpdateNextHop(Face&amp;amp; face, uint64_t cost);</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /** \ZhangYu: adds a NextHop record&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *  2020-8-30，original code has changed to addOrUpdateNextHop in ndnSIM28&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *  2018-1-30, add the face occupied probability for randomized rounding&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  std::pair&amp;lt;NextHopList::iterator, bool&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  addOrUpdateNextHop(Face&amp;amp; face, uint64_t cost, uint64_t probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   /** \brief removes a NextHop record</span>
<span class="ansi32">+</span><span class="ansi32">    *</span>
<span class="ansi32">+</span><span class="ansi32">    *  If no NextHop record for face exists, do nothing.</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/table/fib-nexthop.hpp b/NFD/daemon/table/fib-nexthop.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index e03efda..df3c1bd 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/table/fib-nexthop.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/table/fib-nexthop.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -61,9 +61,26 @@&lt;/span&gt; public:</span>
<span class="ansi32">+</span><span class="ansi32">     m_cost = cost;</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // ZhangYu 2020-8-30,2018-1-30&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  uint64_t&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  getProbability() const&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  return m_probability;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  setProbability(double probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  m_probability=probability;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> private:</span>
<span class="ansi32">+</span><span class="ansi32">   Face* m_face; // pointer instead of reference so that NextHop is movable</span>
<span class="ansi32">+</span><span class="ansi32">   uint64_t m_cost = 0;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /** ZhangYu 2020-8-30 merge the code in fib-nexthop.cpp and fib-nexthop.hpp of 2018-1-30&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *  ZhangYu 2018-1-30 add face occupied probability, in case of randomized rounding&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *  use max() as default value, however maybe never be used.&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  uint64_t m_probability=std::numeric_limits&amp;lt;uint64_t&amp;gt;::max();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> };</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32"> } // namespace fib</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/table/fib.cpp b/NFD/daemon/table/fib.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 99892e6..77b772c 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/table/fib.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/table/fib.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -143,6 +143,18 @@&lt;/span&gt; Fib::addOrUpdateNextHop(Entry&amp;amp; entry, Face&amp;amp; face, uint64_t cost)</span>
<span class="ansi32">+</span><span class="ansi32">     this-&amp;gt;afterNewNextHop(entry.getPrefix(), *it);</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;// ZhangYu 2020-8-30，ndnSIM28相比26新增加的部分&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;Fib::addOrUpdateNextHop(Entry&amp;amp; entry, Face&amp;amp; face, uint64_t cost, uint64_t probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  NextHopList::iterator it;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  bool isNew;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  std::tie(it, isNew) = entry.addOrUpdateNextHop(face, cost, probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  if (isNew)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    this-&amp;gt;afterNewNextHop(entry.getPrefix(), *it);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> Fib::RemoveNextHopResult</span>
<span class="ansi32">+</span><span class="ansi32"> Fib::removeNextHop(Entry&amp;amp; entry, const Face&amp;amp; face)</span>
<span class="ansi32">+</span><span class="ansi32"> {</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/NFD/daemon/table/fib.hpp b/NFD/daemon/table/fib.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index f5984aa..c7cbd1e 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/NFD/daemon/table/fib.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/NFD/daemon/table/fib.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -110,6 +110,13 @@&lt;/span&gt; public: // mutation</span>
<span class="ansi32">+</span><span class="ansi32">   void</span>
<span class="ansi32">+</span><span class="ansi32">   addOrUpdateNextHop(Entry&amp;amp; entry, Face&amp;amp; face, uint64_t cost);</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /** ZhangYu 2020-8-30, 新增加的代码，相比20180908版本&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *  If a NextHop record for \p face already exists in \p entry, its cost is set to \p cost.&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  addOrUpdateNextHop(Entry&amp;amp; entry, Face&amp;amp; face, uint64_t cost, uint64_t probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   enum class RemoveNextHopResult {</span>
<span class="ansi32">+</span><span class="ansi32">     NO_SUCH_NEXTHOP, ///&amp;lt; the nexthop is not found</span>
<span class="ansi32">+</span><span class="ansi32">     NEXTHOP_REMOVED, ///&amp;lt; the nexthop is removed and the fib entry stays</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/examples/ndn-zhangyu-multipath.cpp b/examples/ndn-zhangyu-multipath.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;new file mode 100755&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 0000000..d3147cf&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- /dev/null&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/examples/ndn-zhangyu-multipath.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -0,0 +1,197 @@&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;/*&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * Copyright (c) 2011-2012 University of California, Los Angeles&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * This program is free software; you can redistribute it and/or modify&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * it under the terms of the GNU General Public License version 2 as&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * published by the Free Software Foundation;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * This program is distributed in the hope that it will be useful,&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * but WITHOUT ANY WARRANTY; without even the implied warranty of&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * GNU General Public License for more details.&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * You should have received a copy of the GNU General Public License&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * along with this program; if not, write to the Free Software&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * Author: Alexander Afanasyev &amp;lt;alexander.afanasyev@ucla.edu&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/core-module.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/network-module.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/point-to-point-module.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/point-to-point-layout-module.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/ndnSIM-module.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;//2016-12-7&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/lexical_cast.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/lambda/lambda.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/lambda/bind.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/ndnSIM/helper/ndn-link-control-helper.hpp"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;//ZhangYu 2014-2-7 for DynamicRouting，否则不认识Name，试了很多.h才知道要包含ndn-interest.h&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/names.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/string.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include "ns3/ptr.h"&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/ref.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/lexical_cast.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/lambda/lambda.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;boost/lambda/bind.hpp&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;using namespace std;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;//2017-8-19 try python caculate routes and add to FIB manually&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;//---ZhangYu&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;namespace ns3	{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;/**&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * ZhangYu 2014-3-10，使用BRITE产生的随机网络拓扑，业务量均匀分布在随机的节点对之间&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * 我们这里可以偷懒，因为节点的位置和链路是随机的，所以可以让节点对编号是连续的，效果上应该和均匀分布的随机是一样的。&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * 而且这样拓扑和业务分布可以是固定的，分析数据结果时，可比性强。&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;int&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;main (int argc, char *argv[])&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;bool manualAssign=true;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;int InterestsPerSec=200;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;int simulationSpan=5;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;int TraceSpan=1;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;int recordsNumber=100;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;string routingName="debug";&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//----------------命令行参数----------------&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;CommandLine cmd;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;cmd.AddValue("InterestsPerSec","Interests emit by consumer per second",InterestsPerSec);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;cmd.AddValue("simulationSpan","Simulation span time by seconds",simulationSpan);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;cmd.AddValue ("routingName", "could be Flooding, BestRoute, k-shortest, MultiPathPairFirst, debug", routingName);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;cmd.AddValue ("recordsNumber", "total number of records in tracer file", recordsNumber);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;cmd.Parse(argc,argv);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//std::cout &amp;lt;&amp;lt; "routingName: " &amp;lt;&amp;lt; routingName &amp;lt;&amp;lt; "   " &amp;lt;&amp;lt; InterestsPerSec &amp;lt;&amp;lt; " " &amp;lt;&amp;lt; simulationSpan &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//----------------仿真拓扑----------------&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;AnnotatedTopologyReader topologyReader ("", 20);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//topologyReader.SetFileName ("src/ndnSIM/examples/topologies/26node-result.txt");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;topologyReader.SetFileName ("src/ndnSIM/examples/topologies/topo-for-CompareMultiPath.txt");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;topologyReader.Read ();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;int nodesNumber=topologyReader.GetNodes().size();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//----------------安装Install CCNx stack ----------------&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndn::StackHelper ndnHelper;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// 下面这一句是Install NDN stack on all nodes&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndnHelper.setPolicy("nfd::cs::lru");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndnHelper.setCsSize(1);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndnHelper.InstallAll();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;topologyReader.ApplyOspfMetric();  //使得链路metric生效&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//----------------Installing global routing interface on all nodes ----------------&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndnGlobalRoutingHelper.InstallAll ();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//----------------设置节点的业务 ----------------&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//根据不同的拓扑手工指定或者自动生成业务节点对&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;std::vector&amp;lt;int&amp;gt; consumerNodes,producerNodes;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//生成consumer和producer的节点号动态数组&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;if(manualAssign)	{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;int tmpConsumer[]={0};&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;int tmpProducer[]={2};&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;consumerNodes.assign(tmpConsumer,tmpConsumer+sizeof(tmpConsumer)/sizeof(int));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;producerNodes.assign(tmpProducer,tmpProducer+sizeof(tmpConsumer)/sizeof(int));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;else	{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;for(int i=0;i&amp;lt;nodesNumber/2;i++)	{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  consumerNodes.push_back(i);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;  producerNodes.push_back(i+nodesNumber/2);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//根据上面生成的节点对编号装载应用&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;for(uint32_t i=0;i&amp;lt;consumerNodes.size();i++)	{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndn::AppHelper consumerHelper ("ns3::ndn::ConsumerCbr");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;consumerHelper.SetAttribute("Frequency", StringValue (boost::lexical_cast&amp;lt;std::string&amp;gt;(InterestsPerSec)));        // 100 interests a second&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//ndn::AppHelper consumerHelper("ns3::ndn::ConsumerZipfMandelbrot");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//consumerHelper.SetAttribute("NumberOfContents", StringValue("100")); // 10 different contents&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//可以选择的有：&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//"none": no randomization&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//"uniform": uniform distribution in range (0, 1/Frequency)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//"exponential": exponential distribution with mean 1/Frequency&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;consumerHelper.SetAttribute("Randomize", StringValue("exponential"));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;Ptr&amp;lt;Node&amp;gt; consumer1 = Names::Find&amp;lt;Node&amp;gt; ("Node"+boost::lexical_cast&amp;lt;std::string&amp;gt; (consumerNodes[i]));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;consumerHelper.SetPrefix ("/Node"+boost::lexical_cast&amp;lt;std::string&amp;gt;(consumerNodes[i]));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ApplicationContainer app=consumerHelper.Install(consumer1);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;app.Start(Seconds(0.01*i));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;// Choosing forwarding strategy&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&amp;lt;std::string&amp;gt; (consumerNodes[i]), "/localhost/nfd/strategy/randomized-rounding");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&amp;lt;std::string&amp;gt; (consumerNodes[i]), "/localhost/nfd/strategy/best-route");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&amp;lt;std::string&amp;gt; (consumerNodes[i]), "/localhost/nfd/strategy/ncc");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;std::cout &amp;lt;&amp;lt;"ZhangYu  consumer1-&amp;gt;GetId(): " &amp;lt;&amp;lt;consumer1-&amp;gt;GetId() &amp;lt;&amp;lt; "  prefix: /Node"+boost::lexical_cast&amp;lt;std::string&amp;gt;(consumerNodes[i]) &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;for(uint32_t i=0;i&amp;lt;producerNodes.size();i++)	{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndn::AppHelper producerHelper ("ns3::ndn::Producer");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;producerHelper.SetAttribute ("PayloadSize", StringValue("1024"));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//认为producer节点的Prefix和对应位置的consumer节点一致&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;producerHelper.SetPrefix ("/Node"+boost::lexical_cast&amp;lt;std::string&amp;gt;(consumerNodes[i]));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;Ptr&amp;lt;Node&amp;gt; producer1 = Names::Find&amp;lt;Node&amp;gt; ("Node"+boost::lexical_cast&amp;lt;std::string&amp;gt; (producerNodes[i]));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndnGlobalRoutingHelper.AddOrigins ("/Node"+boost::lexical_cast&amp;lt;std::string&amp;gt;(consumerNodes[i]), producer1);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;producerHelper.Install(producer1);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;std::cout &amp;lt;&amp;lt;"ZhangYu producer1-&amp;gt;GetId(): " &amp;lt;&amp;lt;producer1-&amp;gt;GetId() &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// Calculate and install FIBs&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;if(routingName.compare("BestRoute")==0){&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;  ndn::GlobalRoutingHelper::CalculateRoutes ();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;else if(routingName.compare("debug")==0){&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;//当Consumer是0时，prefix=/Node0时，需要添加 0--&amp;gt;1--&amp;gt;4 的路由才可以，添加反向4-&amp;gt;1-&amp;gt;0没有Traffic&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node2",1,0.9);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node3",1,0.1);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndn::GlobalRoutingHelper::addRouteHop("Node3","/Node0","Node2",1,1.0);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;else if(routingName.compare("Flooding")==0){&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;ndn::GlobalRoutingHelper::CalculateAllPossibleRoutes();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;else{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;std::cout &amp;lt;&amp;lt; "!!!!  ~~~~~~Unkown routingName: " &amp;lt;&amp;lt; routingName &amp;lt;&amp;lt; ", try again..." &amp;lt;&amp;lt;std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// The failure of the link connecting consumer and router will start from seconds 10.0 to 15.0&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//Simulator::Schedule (Seconds (10.0), ndn::LinkControlHelper::FailLink, Names::Find&amp;lt;Node&amp;gt; ("Node0"),Names::Find&amp;lt;Node&amp;gt; ("Node4"));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//Simulator::Schedule (Seconds (15.0), ndn::LinkControlHelper::UpLink,   Names::Find&amp;lt;Node&amp;gt; ("Node0"),Names::Find&amp;lt;Node&amp;gt; ("Node4"));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;Simulator::Stop (Seconds(simulationSpan));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//ZhangYu Add the trace，不愿意文件名称还有大小写的区别，所以把 routingName 全部转为小写&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;std::transform(routingName.begin(), routingName.end(), routingName.begin(), ::tolower);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;string filename="-"+routingName+"-"+boost::lexical_cast&amp;lt;std::string&amp;gt;(InterestsPerSec)+".txt";&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//filename=".txt";&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;TraceSpan=simulationSpan/recordsNumber;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;if(TraceSpan&amp;lt;1)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;TraceSpan=1;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndn::CsTracer::InstallAll ("Results/cs-trace"+filename, Seconds (TraceSpan));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndn::L3RateTracer::InstallAll ("Results/rate-trace"+filename, Seconds (TraceSpan));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// L3AggregateTracer disappeared in new version&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//ndn::L3AggregateTracer::InstallAll ("Results/aggregate-trace-"+filename, Seconds (1));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;ndn::AppDelayTracer::InstallAll ("Results/app-delays-trace"+filename);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;L2RateTracer::InstallAll ("Results/drop-trace"+filename, Seconds (TraceSpan));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;Simulator::Run ();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;Simulator::Destroy ();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  return 0;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;} // namespace ns3&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;int&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;main(int argc, char* argv[])&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  return ns3::main(argc, argv);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/examples/topologies/topo-load-balancer2.txt b/examples/topologies/topo-load-balancer2.txt&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;new file mode 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 0000000..26023f7&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- /dev/null&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/examples/topologies/topo-load-balancer2.txt&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -0,0 +1,52 @@&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# topo-load-balancer.txt&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# 拓扑的坐标不能为0，否则--vis显示不正常，因此在上面的拓扑中全部加1平移&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#                          /-----\&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#                          | CSU |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#                 +-----&amp;gt;  | HUB |  &amp;lt;----+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#                 |        \-----/       |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#                 |                      |  1Mbps/10ms delay&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#                 v                      v&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#               /------\               /----------\&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#               | UCLA |               | Consumer |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#               | HUB  |               |   CSU-1  |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#       +-----&amp;gt; \------/ &amp;lt;-----+       \----------/&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#       |                      |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#       |                      |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#       v                      v&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#   /----------\           /----------\&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#   | Producer |           | Producer |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#   |  UCLA-1  |           |  UCLA-2  |&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#   \----------/           \----------/&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# any empty lines and lines starting with '#' symbol is ignored&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# The file should contain exactly two sections: router and link, each starting with the corresponding keyword&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# router section defines topology nodes and their relative positions (e.g., to use in visualizer)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;router&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# each line in this section represents one router and should have the following data&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# node   comment    yPos    xPos&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;CSU-1    NA          4       6&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;CSU-HUB  NA          5       4&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;UCLA-HUB NA          4       2&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;UCLA-1   NA          1       1&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;UCLA-2   NA          1       3&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# Note that `node` can be any string. It is possible to access to the node by name using Names::Find, see examples.&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# link section defines point-to-point links between nodes and characteristics of these links&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;link&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# Each line should be in the following format (only first two are required, the rest can be omitted)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# srcNode   dstNode     bandwidth   metric  delay   queue&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# bandwidth: link bandwidth&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# metric: routing metric&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# delay:  link delay&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;# queue:  MaxPackets for transmission queue on the link (both directions)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;CSU-1       CSU-HUB     1Mbps       1       10ms    10&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;CSU-HUB     UCLA-HUB    1Mbps       1       10ms    10&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;UCLA-HUB    UCLA-1      1Mbps       1       10ms    10&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;UCLA-HUB    UCLA-2      1Mbps       1       10ms    10&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/helper/ndn-fib-helper.cpp b/helper/ndn-fib-helper.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 921c20f..42cc790 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/helper/ndn-fib-helper.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/helper/ndn-fib-helper.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -169,6 +169,78 @@&lt;/span&gt; FibHelper::AddRoute(const std::string&amp;amp; nodeName, const Name&amp;amp; prefix,</span>
<span class="ansi32">+</span><span class="ansi32">   AddRoute(node, prefix, otherNode, metric);</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;/* ****************************ZhangYu 2020-8-30 添加 Randomized Rounding******************************&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * ZhangYu 2020-8-30 估计原来是考虑到只是增加了Probability，移除时可以使用Metric的移除直接移除，没有增加Remove&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * ZhangYu 2018-1-31 添加了端口概率，为了方便，将所有调用的函数都排在后面&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; * 2018-2-1 在tlv格式中，因为浮点数编码复杂，所有只处理整数类型，因为将probability在数据源头将其变为整数，使用时复原&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt; */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;FibHelper::AddRoute(const std::string&amp;amp; nodeName, const Name&amp;amp; prefix,&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;                    const std::string&amp;amp; otherNodeName, int32_t metric, int32_t probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  Ptr&amp;lt;Node&amp;gt; node = Names::Find&amp;lt;Node&amp;gt;(nodeName);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  NS_ASSERT_MSG(node != 0, "Node [" &amp;lt;&amp;lt; nodeName &amp;lt;&amp;lt; "] does not exist");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  Ptr&amp;lt;Node&amp;gt; otherNode = Names::Find&amp;lt;Node&amp;gt;(otherNodeName);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  NS_ASSERT_MSG(otherNode != 0, "Node [" &amp;lt;&amp;lt; otherNodeName &amp;lt;&amp;lt; "] does not exist");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  AddRoute(node, prefix, otherNode, metric, probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;FibHelper::AddRoute(Ptr&amp;lt;Node&amp;gt; node, const Name&amp;amp; prefix, Ptr&amp;lt;Node&amp;gt; otherNode, int32_t metric, int32_t probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  for (uint32_t deviceId = 0; deviceId &amp;lt; node-&amp;gt;GetNDevices(); deviceId++) {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    Ptr&amp;lt;PointToPointNetDevice&amp;gt; netDevice =&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      DynamicCast&amp;lt;PointToPointNetDevice&amp;gt;(node-&amp;gt;GetDevice(deviceId));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    if (netDevice == 0)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      continue;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    Ptr&amp;lt;Channel&amp;gt; channel = netDevice-&amp;gt;GetChannel();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    if (channel == 0)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      continue;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    if (channel-&amp;gt;GetDevice(0)-&amp;gt;GetNode() == otherNode&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;        || channel-&amp;gt;GetDevice(1)-&amp;gt;GetNode() == otherNode) {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      Ptr&amp;lt;L3Protocol&amp;gt; ndn = node-&amp;gt;GetObject&amp;lt;L3Protocol&amp;gt;();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      NS_ASSERT_MSG(ndn != 0, "Ndn stack should be installed on the node");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      shared_ptr&amp;lt;Face&amp;gt; face = ndn-&amp;gt;getFaceByNetDevice(netDevice);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      NS_ASSERT_MSG(face != 0, "There is no face associated with the p2p link");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      AddRoute(node, prefix, face, metric, probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;      return;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;FibHelper::AddRoute(Ptr&amp;lt;Node&amp;gt; node, const Name&amp;amp; prefix, shared_ptr&amp;lt;Face&amp;gt; face, int32_t metric, int32_t probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  NS_LOG_LOGIC("[" &amp;lt;&amp;lt; node-&amp;gt;GetId() &amp;lt;&amp;lt; "]$ route add " &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; " via " &amp;lt;&amp;lt; face-&amp;gt;getLocalUri()&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;                   &amp;lt;&amp;lt; " metric " &amp;lt;&amp;lt; metric);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // Get L3Protocol object&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  Ptr&amp;lt;L3Protocol&amp;gt; L3protocol = node-&amp;gt;GetObject&amp;lt;L3Protocol&amp;gt;();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // Get the forwarder instance&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  shared_ptr&amp;lt;nfd::Forwarder&amp;gt; m_forwarder = L3protocol-&amp;gt;getForwarder();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  ControlParameters parameters;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  parameters.setName(prefix);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  parameters.setFaceId(face-&amp;gt;getId());&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  parameters.setCost(metric);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  parameters.setProbability(probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  AddNextHop(parameters, node);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //ZhangYu 2018-2-1&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //std::cout &amp;lt;&amp;lt;"2018-2-1 FibHelper::AddRoute -- probability:" &amp;lt;&amp;lt; probability &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //std::cout &amp;lt;&amp;lt; parameters &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;// *********************************************************************************&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> void</span>
<span class="ansi32">+</span><span class="ansi32"> FibHelper::RemoveRoute(Ptr&amp;lt;Node&amp;gt; node, const Name&amp;amp; prefix, shared_ptr&amp;lt;Face&amp;gt; face)</span>
<span class="ansi32">+</span><span class="ansi32"> {</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/helper/ndn-fib-helper.hpp b/helper/ndn-fib-helper.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 381ee2d..2306e47 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/helper/ndn-fib-helper.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/helper/ndn-fib-helper.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -100,6 +100,46 @@&lt;/span&gt; public:</span>
<span class="ansi32">+</span><span class="ansi32">   AddRoute(const std::string&amp;amp; nodeName, const Name&amp;amp; prefix, const std::string&amp;amp; otherNodeName,</span>
<span class="ansi32">+</span><span class="ansi32">            int32_t metric);</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /*************************************所有需要调用的函数都放在后面*****************************&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * ZhangYu 2020-8-30，2018-1-31 Add forwarding entry with face probability&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param nodeName Node name (refer to ns3::Names)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param prefix Routing prefix&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param otherNode The other node name, to which interests (will be&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *                  used to infer face id (refer to ns3::Names)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param metric Routing metric&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param probability take face by probability&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  static void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  AddRoute(const std::string&amp;amp; nodeName, const Name&amp;amp; prefix, const std::string&amp;amp; otherNodeName,&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;           int32_t metric, int32_t probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /**&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * @brief Add forwarding entry to FIB (work only with point-to-point links)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param node Node&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param prefix Routing prefix&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param otherNode The other node, to which interests (will be used to infer face id&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param metric Routing metric&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param probability take face by probability&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  static void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  AddRoute(Ptr&amp;lt;Node&amp;gt; node, const Name&amp;amp; prefix, Ptr&amp;lt;Node&amp;gt; otherNode, int32_t metric, int32_t probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /**&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \brief Add forwarding entry to FIB&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   *&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param node   Node&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param prefix Routing prefix&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param face   Face&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * \param metric Routing metric&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  static void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  AddRoute(Ptr&amp;lt;Node&amp;gt; node, const Name&amp;amp; prefix, shared_ptr&amp;lt;Face&amp;gt; face, int32_t metric, int32_t probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //***************************************************************************************&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   /**</span>
<span class="ansi32">+</span><span class="ansi32">    * \brief remove forwarding entry in FIB</span>
<span class="ansi32">+</span><span class="ansi32">    *</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/helper/ndn-global-routing-helper.cpp b/helper/ndn-global-routing-helper.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index ebc4617..c27fbff 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/helper/ndn-global-routing-helper.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/helper/ndn-global-routing-helper.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -386,5 +386,38 @@&lt;/span&gt; GlobalRoutingHelper::CalculateAllPossibleRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;// ZhangYu 2020-8-30, 2017-8-19 abandon scenarioHelper&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;void GlobalRoutingHelper::addRouteHop(const std::string edgeStart,const std::string prefix,const std::string edgeEnd, std::int32_t metric)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;/*&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;Py_Initialize();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;if(!Py_IsInitialized())&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;std::cout &amp;lt;&amp;lt; "can't Initialize python" &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;std::string path="~/OneDrive/SCIP_STP/scipLearn1";&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;std::string chdir_cmd=std::string("sys.path.append(\""+path+"\")");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;const char* cstr_cmd=chdir_cmd.c_str();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;PyRun_SimpleString("import sys");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;//PyRun_SimpleString(cstr_cmd);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;PyObject *pName=PyString_FromString("learning");&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;PyObject *pModule=PyImport_Import(pName);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;if(!pModule)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;std::cout &amp;lt;&amp;lt; "can't find learning.py " &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;*/&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    FibHelper::AddRoute(edgeStart, prefix, edgeEnd,metric);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;// ZhangYu 2020-8-30, 2018-1-30 add probability for node&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;void GlobalRoutingHelper::addRouteHop(const std::string edgeStart,const std::string prefix,const std::string edgeEnd, std::int32_t metric,&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;		&lt;span class="ansi32"&gt;std::double_t probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;{&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// ZhangYu 2018-2-1 因为浮点数的编码比较复杂，会导致处理速度慢。估计是由于这个原因在TLV格式的数据包中，只有几种不同长度的整数&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// 为了表示端口的占用概率，或者实现带宽的分配，需要浮点数，这里采用了简单的做法，放大后取整&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    FibHelper::AddRoute(edgeStart, prefix, edgeEnd, metric, std::round(probability*1000000));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;}&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> } // namespace ndn</span>
<span class="ansi32">+</span><span class="ansi32"> } // namespace ns3</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/helper/ndn-global-routing-helper.hpp b/helper/ndn-global-routing-helper.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index d14b2fe..7a0e052 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/helper/ndn-global-routing-helper.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/helper/ndn-global-routing-helper.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -124,6 +124,21 @@&lt;/span&gt; public:</span>
<span class="ansi32">+</span><span class="ansi32">   static void</span>
<span class="ansi32">+</span><span class="ansi32">   CalculateAllPossibleRoutes();</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /* ZhangYu 2020-8-30&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * @ZY, 2017-8-19 try to caculate routes by python, and use the python results in ns3 c++&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * add next hop for a route&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * 原本打算用scenarioHelper来实现，结果发现它自成体系，拓扑和节点都用自己的，所以放弃&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  static void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  addRouteHop(const std::string edgeStart,const std::string prefix, const std::string edgeEnd, std::int32_t metri);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /* ZhangYu 2020-8-30&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * @ZY, 2018-1-30 add probability for the consumer node, in case of randomized rounding&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   */&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  static void&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  addRouteHop(const std::string edgeStart,const std::string prefix, const std::string edgeEnd, std::int32_t metri, std::double_t probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> private:</span>
<span class="ansi32">+</span><span class="ansi32">   void</span>
<span class="ansi32">+</span><span class="ansi32">   Install(Ptr&amp;lt;Channel&amp;gt; channel);</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/ndn-cxx/ndn-cxx/encoding/tlv-nfd.hpp b/ndn-cxx/ndn-cxx/encoding/tlv-nfd.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 1c30ab4..b134b5d 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/ndn-cxx/ndn-cxx/encoding/tlv-nfd.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/ndn-cxx/ndn-cxx/encoding/tlv-nfd.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -37,6 +37,7 @@&lt;/span&gt; enum {</span>
<span class="ansi32">+</span><span class="ansi32">   Uri                 = 114,</span>
<span class="ansi32">+</span><span class="ansi32">   Origin              = 111,</span>
<span class="ansi32">+</span><span class="ansi32">   Cost                = 106,</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  Probability		  = 113, //ZhangYu 2020-8-30, 2018-1-31&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   Capacity            = 131,</span>
<span class="ansi32">+</span><span class="ansi32">   Count               = 132,</span>
<span class="ansi32">+</span><span class="ansi32">   Flags               = 108,</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/ndn-cxx/ndn-cxx/mgmt/nfd/control-command.cpp b/ndn-cxx/ndn-cxx/mgmt/nfd/control-command.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 86ca500..89cb13d 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/ndn-cxx/ndn-cxx/mgmt/nfd/control-command.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/ndn-cxx/ndn-cxx/mgmt/nfd/control-command.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -203,11 +203,15 @@&lt;/span&gt; FibAddNextHopCommand::FibAddNextHopCommand()</span>
<span class="ansi32">+</span><span class="ansi32">   m_requestValidator</span>
<span class="ansi32">+</span><span class="ansi32">     .required(CONTROL_PARAMETER_NAME)</span>
<span class="ansi32">+</span><span class="ansi32">     .optional(CONTROL_PARAMETER_FACE_ID)</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-    .optional(CONTROL_PARAMETER_COST);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    .optional(CONTROL_PARAMETER_COST)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// ZhangYu 2018-2-1，是必要的还是可选的&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;.optional(CONTROL_PARAMETER_PROBABILITY);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   m_responseValidator</span>
<span class="ansi32">+</span><span class="ansi32">     .required(CONTROL_PARAMETER_NAME)</span>
<span class="ansi32">+</span><span class="ansi32">     .required(CONTROL_PARAMETER_FACE_ID)</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-    .required(CONTROL_PARAMETER_COST);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    .required(CONTROL_PARAMETER_COST)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;// ZhangYu 2018-2-1，是必要的还是可选的，当写成.required后，不用 probability会导致出错&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi41"&gt;  &lt;/span&gt;	&lt;span class="ansi32"&gt;.optional(CONTROL_PARAMETER_PROBABILITY);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> }</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32"> void</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.cpp b/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index 6c8f091..3651b11 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.cpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -25,6 +25,9 @@&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> #include "ndn-cxx/util/concepts.hpp"</span>
<span class="ansi32">+</span><span class="ansi32"> #include "ndn-cxx/util/string-helper.hpp"</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;// ZhangYu 2020-8-30 for debug cout&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32"> namespace ndn {</span>
<span class="ansi32">+</span><span class="ansi32"> namespace nfd {</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -84,6 +87,11 @@&lt;/span&gt; ControlParameters::wireEncode(EncodingImpl&amp;lt;TAG&amp;gt;&amp;amp; encoder) const</span>
<span class="ansi32">+</span><span class="ansi32">   if (this-&amp;gt;hasCapacity()) {</span>
<span class="ansi32">+</span><span class="ansi32">     totalLength += prependNonNegativeIntegerBlock(encoder, tlv::nfd::Capacity, m_capacity);</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // ZhangYu 2020-8-30,2018-1-31&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  if (this-&amp;gt;hasProbability()){&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;	&lt;span class="ansi32"&gt;totalLength += prependNonNegativeIntegerBlock(encoder, tlv::nfd::Probability, m_probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    //std::cout &amp;lt;&amp;lt; "ZhangYu 2018-1-31 wireEncode--  m_probability:" &amp;lt;&amp;lt; m_probability &amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   if (this-&amp;gt;hasCost()) {</span>
<span class="ansi32">+</span><span class="ansi32">     totalLength += prependNonNegativeIntegerBlock(encoder, tlv::nfd::Cost, m_cost);</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -172,7 +180,13 @@&lt;/span&gt; ControlParameters::wireDecode(const Block&amp;amp; block)</span>
<span class="ansi32">+</span><span class="ansi32">   if (this-&amp;gt;hasCost()) {</span>
<span class="ansi32">+</span><span class="ansi32">     m_cost = readNonNegativeInteger(*val);</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi31"&gt;-&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // ZhangYu 2018-1-31&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  val = m_wire.find(tlv::nfd::Probability);&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  m_hasFields[CONTROL_PARAMETER_PROBABILITY] = val != m_wire.elements_end();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  if (this-&amp;gt;hasProbability()) {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    m_probability = static_cast&amp;lt;uint64_t&amp;gt;(readNonNegativeInteger(*val));&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    //std::cout &amp;lt;&amp;lt; "ZhangYu 2018-1-31 ControlParameters::wireDecode--  m_probability:" &amp;lt;&amp;lt; m_probability&amp;lt;&amp;lt; std::endl;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   val = m_wire.find(tlv::nfd::Capacity);</span>
<span class="ansi32">+</span><span class="ansi32">   m_hasFields[CONTROL_PARAMETER_CAPACITY] = val != m_wire.elements_end();</span>
<span class="ansi32">+</span><span class="ansi32">   if (this-&amp;gt;hasCapacity()) {</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -341,6 +355,10 @@&lt;/span&gt; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const ControlParameters&amp;amp; parameters)</span>
<span class="ansi32">+</span><span class="ansi32">   if (parameters.hasCost()) {</span>
<span class="ansi32">+</span><span class="ansi32">     os &amp;lt;&amp;lt; "Cost: " &amp;lt;&amp;lt; parameters.getCost() &amp;lt;&amp;lt; ", ";</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  // ZhangYu 2018-1-31&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  if (parameters.hasProbability()) {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    os &amp;lt;&amp;lt; "Probability: " &amp;lt;&amp;lt; parameters.getProbability() &amp;lt;&amp;lt; ", ";&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">   if (parameters.hasCapacity()) {</span>
<span class="ansi32">+</span><span class="ansi32">     os &amp;lt;&amp;lt; "Capacity: " &amp;lt;&amp;lt; parameters.getCapacity() &amp;lt;&amp;lt; ", ";</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;diff --git a/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp b/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;index d23cc27..069e1e7 100644&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;--- a/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi1"&gt;+++ b/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -40,6 +40,7 @@&lt;/span&gt; enum ControlParameterField {</span>
<span class="ansi32">+</span><span class="ansi32">   CONTROL_PARAMETER_LOCAL_URI,</span>
<span class="ansi32">+</span><span class="ansi32">   CONTROL_PARAMETER_ORIGIN,</span>
<span class="ansi32">+</span><span class="ansi32">   CONTROL_PARAMETER_COST,</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  CONTROL_PARAMETER_PROBABILITY, //ZhangYu 2020-8-30,参考 2018-1-31&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   CONTROL_PARAMETER_CAPACITY,</span>
<span class="ansi32">+</span><span class="ansi32">   CONTROL_PARAMETER_COUNT,</span>
<span class="ansi32">+</span><span class="ansi32">   CONTROL_PARAMETER_FLAGS,</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -60,6 +61,7 @@&lt;/span&gt; const std::string CONTROL_PARAMETER_FIELD[CONTROL_PARAMETER_UBOUND] = {</span>
<span class="ansi32">+</span><span class="ansi32">   "LocalUri",</span>
<span class="ansi32">+</span><span class="ansi32">   "Origin",</span>
<span class="ansi32">+</span><span class="ansi32">   "Cost",</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  "Probability", //ZhangYu 2020-8-30&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   "Capacity",</span>
<span class="ansi32">+</span><span class="ansi32">   "Count",</span>
<span class="ansi32">+</span><span class="ansi32">   "Flags",</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -282,7 +284,38 @@&lt;/span&gt; public: // getters &amp;amp; setters</span>
<span class="ansi32">+</span><span class="ansi32">     m_hasFields[CONTROL_PARAMETER_COST] = false;</span>
<span class="ansi32">+</span><span class="ansi32">     return *this;</span>
<span class="ansi32">+</span><span class="ansi32">   }</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  /* ZhangYu 2020-8-30 modified for ndnSIM28 *************************&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;   * ZhangYu 2018-1-31  add take face by probability *****************/&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  bool&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  hasProbability() const&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    return m_hasFields[CONTROL_PARAMETER_PROBABILITY];&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  uint64_t&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  getProbability() const&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    BOOST_ASSERT(this-&amp;gt;hasProbability());&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    return m_probability;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  ControlParameters&amp;amp;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  setProbability(uint64_t probability)&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    m_wire.reset();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    m_probability = probability;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    m_hasFields[CONTROL_PARAMETER_PROBABILITY] = true;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    return *this;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  ControlParameters&amp;amp;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  unsetProbability()&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  {&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    m_wire.reset();&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    m_hasFields[CONTROL_PARAMETER_PROBABILITY] = false;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;    return *this;&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  }&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  //*****************************************************************/&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   bool</span>
<span class="ansi32">+</span><span class="ansi32">   hasCapacity() const</span>
<span class="ansi32">+</span><span class="ansi32">   {</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi36"&gt;@@ -642,6 +675,7 @@&lt;/span&gt; private: // fields</span>
<span class="ansi32">+</span><span class="ansi32">   std::string         m_localUri;</span>
<span class="ansi32">+</span><span class="ansi32">   RouteOrigin         m_origin;</span>
<span class="ansi32">+</span><span class="ansi32">   uint64_t            m_cost;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;span class="ansi32"&gt;+&lt;/span&gt;&lt;span class="ansi32"&gt;  uint64_t			  m_probability; // ZhangYu 2020-8-30,2018-1-31&lt;/span&gt;</span>
<span class="ansi32">+</span><span class="ansi32">   uint64_t            m_capacity;</span>
<span class="ansi32">+</span><span class="ansi32">   uint64_t            m_count;</span>
<span class="ansi32">+</span><span class="ansi32">   uint64_t            m_flags;</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">&lt;/pre&gt;</span>
<span class="ansi32">+</span><span class="ansi32">&lt;/body&gt;</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">&lt;/html&gt;</span>
<span class="ansi1">diff --git a/NFD/daemon/fw/randomized-rounding-strategy.cpp b/NFD/daemon/fw/randomized-rounding-strategy.cpp</span>
<span class="ansi1">index 986ff53..a519632 100644</span>
<span class="ansi1">--- a/NFD/daemon/fw/randomized-rounding-strategy.cpp</span>
<span class="ansi1">+++ b/NFD/daemon/fw/randomized-rounding-strategy.cpp</span>
<span class="ansi36">@@ -79,6 +79,12 @@</span> RandomizedRoundingStrategy::afterReceiveInterest(const FaceEndpoint&amp; ingress, co
     this-&gt;rejectPendingInterest(pitEntry);
     return;
   }
<span class="ansi32">+</span><span class="ansi32">  /*</span>
<span class="ansi32">+</span><span class="ansi32">  std::shuffle(nhs.begin(), nhs.end(), ndn::random::getRandomNumberEngine());</span>
<span class="ansi32">+</span><span class="ansi32">  this-&gt;sendInterest(pitEntry, FaceEndpoint(nhs.front().getFace(), 0), interest);</span>
<span class="ansi32">+</span><span class="ansi32">  NFD_LOG_DEBUG(std::endl &lt;&lt; "      ZhangYu 2018-11-6: afterReceiveInterest-- Random "</span>
<span class="ansi32">+</span><span class="ansi32">      &lt;&lt; " face: " &lt;&lt; FaceEndpoint(nhs.front().getFace(), 0) &lt;&lt; "    interest:" &lt;&lt; interest);</span>
<span class="ansi32">+</span><span class="ansi32">  */</span>
   // ZhangYu 2020-8-30
   boost::random::uniform_01&lt;boost::random::mt19937&amp;&gt; dist(m_randomGenerator);
   //dist.reset();
<span class="ansi36">@@ -91,22 +97,21 @@</span> RandomizedRoundingStrategy::afterReceiveInterest(const FaceEndpoint&amp; ingress, co
   for(selected=nhs.begin(); selected !=nhs.end(); ++selected) {
 	  index=index+1;
 	  probabilitySum+=selected-&gt;getProbability();
<span class="ansi32">+</span>	<span class="ansi32">  //std::cout &lt;&lt; "ZhangYu 2018-3-25 probabilitySum: " &lt;&lt; probabilitySum &lt;&lt; "  ingeress: " &lt;&lt; ingress &lt;&lt; std::endl;</span>
 	  //ZhangYu 2018-4-6这里是否加=应该影响不大，主要担心的是概率为0和1的记录，但都是小概率事件。
 	  if(randomValue&lt;=probabilitySum){
 		  this-&gt;sendInterest(pitEntry, FaceEndpoint(selected-&gt;getFace(),0), interest);
<span class="ansi31">-		  /*</span>
<span class="ansi31">-		  std::cout &lt;&lt; "      ZhangYu 2018-2-1 afterReceiveInterest-- "</span>
<span class="ansi32">+</span>		<span class="ansi32">  /**/</span>
<span class="ansi32">+</span>		<span class="ansi32">  NFD_LOG_DEBUG(std::endl &lt;&lt; "      ZhangYu 2018-2-1 afterReceiveInterest-- "</span>
 				  &lt;&lt; " face: " &lt;&lt; FaceEndpoint(selected-&gt;getFace(),0)
 				  &lt;&lt; " cost: " &lt;&lt; selected-&gt;getCost()
<span class="ansi31">-				  &lt;&lt; " probability: " &lt;&lt; selected-&gt;getProbability() &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>				<span class="ansi32">  &lt;&lt; " probability: " &lt;&lt; selected-&gt;getProbability());</span>
 
<span class="ansi31">-		  std::cout &lt;&lt; "!!ZhangYu 2018-3-25, index:" &lt;&lt; index &lt;&lt; std::endl;</span>
<span class="ansi31">-		  */</span>
<span class="ansi32">+</span>		<span class="ansi32">  NFD_LOG_DEBUG(std::endl  &lt;&lt; "!!ZhangYu 2018-3-25, index:" &lt;&lt; index &lt;&lt; "    interest:" &lt;&lt; interest &lt;&lt; std::endl);</span>
<span class="ansi32">+</span><span class="ansi41">		  </span>
 		  return;
 	  }
   }
<span class="ansi31">-  //std::shuffle(nhs.begin(), nhs.end(), ndn::random::getRandomNumberEngine());</span>
<span class="ansi31">-  //this-&gt;sendInterest(pitEntry, FaceEndpoint(nhs.front().getFace(), 0), interest);</span>
 }
 
 void
<span class="ansi1">diff --git a/NFD/daemon/mgmt/fib-manager.cpp b/NFD/daemon/mgmt/fib-manager.cpp</span>
<span class="ansi1">index 98df452..4f7328a 100644</span>
<span class="ansi1">--- a/NFD/daemon/mgmt/fib-manager.cpp</span>
<span class="ansi1">+++ b/NFD/daemon/mgmt/fib-manager.cpp</span>
<span class="ansi36">@@ -61,8 +61,11 @@</span> FibManager::addNextHop(const Name&amp; topPrefix, const Interest&amp; interest,
   const Name&amp; prefix = parameters.getName();
   FaceId faceId = parameters.getFaceId();
   uint64_t cost = parameters.getCost();
<span class="ansi31">-  // ZhangYu 2020-8-30,2018-2-1</span>
<span class="ansi31">-  uint64_t probability=std::numeric_limits&lt;uint64_t&gt;::max();</span>
<span class="ansi32">+</span><span class="ansi32">  // ZhangYu 2020-8-30,2018-2-1,</span>
<span class="ansi32">+</span><span class="ansi32">  // 2020-11-6，原本这里probability的默认值设置为 std::numeric_limits&lt;uint64_t&gt;::max()-1</span>
<span class="ansi32">+</span><span class="ansi32">  // 而setProbability中以double型接受参数，保存在uint64的m_probability中时，转换为0，结果导致在获取时总得到 0</span>
<span class="ansi32">+</span><span class="ansi32">  // 源代码中cost的值在数据传输使用uint64，但中间处理使用int32，probability也一致。默认值统一成int32::max-1</span>
<span class="ansi32">+</span><span class="ansi32">  uint64_t probability=std::numeric_limits&lt;int32_t&gt;::max()-1;</span>
   if(parameters.hasProbability()){
 	  probability=parameters.getProbability();
 	  //std::cout &lt;&lt; "ZhangYu 2018-2-1 FibManager::addNexHop probability: " &lt;&lt; probability &lt;&lt; std::endl;
<span class="ansi1">diff --git a/NFD/daemon/table/fib-entry.cpp b/NFD/daemon/table/fib-entry.cpp</span>
<span class="ansi1">index fb5610d..4502729 100644</span>
<span class="ansi1">--- a/NFD/daemon/table/fib-entry.cpp</span>
<span class="ansi1">+++ b/NFD/daemon/table/fib-entry.cpp</span>
<span class="ansi36">@@ -65,7 +65,9 @@</span> Entry::addOrUpdateNextHop(Face&amp; face, uint64_t cost)
   return std::make_pair(it, isNew);
 }
 
<span class="ansi31">-//ZhangYu 2020-8-30,2018-1-30</span>
<span class="ansi32">+</span><span class="ansi32">//ZhangYu 2020-8-30,2018-1-30,</span>
<span class="ansi32">+</span><span class="ansi32">//2020-11-6  将其修改为 unit16_t，就可以得到 probability 是 65534，而不是0</span>
<span class="ansi32">+</span><span class="ansi32">// 所以估计是 这里函数会设置最大值 1.8e19次，导致以后getProbability 值时溢出成 0</span>
 std::pair&lt;NextHopList::iterator, bool&gt;
 Entry::addOrUpdateNextHop(Face&amp; face, uint64_t cost, uint64_t probability)
 {
<span class="ansi36">@@ -77,7 +79,10 @@</span> Entry::addOrUpdateNextHop(Face&amp; face, uint64_t cost, uint64_t probability)
 	isNew = true;
 	  }
   it-&gt;setCost(cost);
<span class="ansi32">+</span>
   it-&gt;setProbability(probability);
<span class="ansi32">+</span><span class="ansi32">  //std::cout &lt;&lt; "--------ZhangYu 2020-11-6 fib-entry setProbability: " &lt;&lt; probability &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>
   this-&gt;sortNextHops();
 
   return std::make_pair(it, isNew);
<span class="ansi1">diff --git a/NFD/daemon/table/fib-nexthop.hpp b/NFD/daemon/table/fib-nexthop.hpp</span>
<span class="ansi1">index df3c1bd..a54e0f7 100644</span>
<span class="ansi1">--- a/NFD/daemon/table/fib-nexthop.hpp</span>
<span class="ansi1">+++ b/NFD/daemon/table/fib-nexthop.hpp</span>
<span class="ansi36">@@ -65,12 +65,16 @@</span> public:
   uint64_t
   getProbability() const
   {
<span class="ansi32">+</span><span class="ansi32">    //std::cout &lt;&lt; "=========probability 获取:" &lt;&lt; m_probability &lt;&lt; std::endl;</span>
 	  return m_probability;
   }
   void
<span class="ansi31">-  setProbability(double probability)</span>
<span class="ansi32">+</span><span class="ansi32">  // 2020-11-6 原来是设置了 unit64_t的最大值 18446744073709551614，这里用double 去取，结果为0</span>
<span class="ansi32">+</span><span class="ansi32">  setProbability(uint64_t probability)</span>
   {
<span class="ansi32">+</span><span class="ansi32">    //std::cout &lt;&lt; "=========probability 设置:" &lt;&lt; probability &lt;&lt; std::endl;</span>
 	  m_probability=probability;
<span class="ansi32">+</span>	<span class="ansi32">//std::cout &lt;&lt; "=========m_probability 设置:" &lt;&lt; m_probability &lt;&lt; std::endl;</span>
   }
 
 private:
<span class="ansi36">@@ -80,7 +84,8 @@</span> private:
    *  ZhangYu 2018-1-30 add face occupied probability, in case of randomized rounding
    *  use max() as default value, however maybe never be used.
    */
<span class="ansi31">-  uint64_t m_probability=std::numeric_limits&lt;uint64_t&gt;::max();</span>
<span class="ansi32">+</span><span class="ansi32">  //uint64_t m_probability=std::numeric_limits&lt;uint64_t&gt;::max()-1;</span>
<span class="ansi32">+</span><span class="ansi32">  uint64_t m_probability=std::numeric_limits&lt;int32_t&gt;::max()-1;</span>
 };
 
 } // namespace fib
<span class="ansi1">diff --git a/apps/ndn-producer.cpp b/apps/ndn-producer.cpp</span>
<span class="ansi1">index 87e7a94..b99ec8f 100644</span>
<span class="ansi1">--- a/apps/ndn-producer.cpp</span>
<span class="ansi1">+++ b/apps/ndn-producer.cpp</span>
<span class="ansi36">@@ -80,6 +80,7 @@</span> Producer::StartApplication()
   App::StartApplication();
 
   FibHelper::AddRoute(GetNode(), m_prefix, m_face, 0);
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_DEBUG("ZhangYu 2020-11-6:  Producer App is Started");</span>
 }
 
 void
<span class="ansi36">@@ -96,7 +97,9 @@</span> Producer::OnInterest(shared_ptr&lt;const Interest&gt; interest)
   App::OnInterest(interest); // tracing inside
 
   NS_LOG_FUNCTION(this &lt;&lt; interest);
<span class="ansi31">-</span>
<span class="ansi32">+</span><span class="ansi41">  </span>
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_DEBUG("ZhangYu 2020-11-6:  interest:" &lt;&lt; interest);</span>
<span class="ansi32">+</span><span class="ansi41">  </span>
   if (!m_active)
     return;
 
<span class="ansi1">diff --git "a/bindings/modulegen__gcc_ILP64.py.\344\273\216201809\345\244\215\345\210\266\346\235\245\347\232\204\346\211\213\345\267\245\344\277\256\346\224\271\350\277\207\347\232\204\357\274\214\344\275\206\346\212\245\351\224\231" "b/bindings/modulegen__gcc_ILP64.py.\344\273\216201809\345\244\215\345\210\266\346\235\245\347\232\204\346\211\213\345\267\245\344\277\256\346\224\271\350\277\207\347\232\204\357\274\214\344\275\206\346\212\245\351\224\231"</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..ff9930b</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ "b/bindings/modulegen__gcc_ILP64.py.\344\273\216201809\345\244\215\345\210\266\346\235\245\347\232\204\346\211\213\345\267\245\344\277\256\346\224\271\350\277\207\347\232\204\357\274\214\344\275\206\346\212\245\351\224\231"</span>
<span class="ansi36">@@ -0,0 +1,591 @@</span>
<span class="ansi32">+</span><span class="ansi32"># if use Chinese symbol then there will be error</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">from pybindgen.typehandlers.smart_ptr import StdSharedPtr</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">from ns3_ptr import Ns3PtrMemoryPolicy</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">import pybindgen.settings</span>
<span class="ansi32">+</span><span class="ansi32">import warnings</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">import sys</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def module_init():</span>
<span class="ansi32">+</span><span class="ansi32">    root_module = Module('ns.ndnSIM', cpp_namespace='::ns3')</span>
<span class="ansi32">+</span><span class="ansi32">    return root_module</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def register_types(module):</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core',</span>
<span class="ansi32">+</span><span class="ansi32">                     template_parameters=['ns3::Object', 'ns3::ObjectBase', 'ns3::ObjectDeleter'],</span>
<span class="ansi32">+</span><span class="ansi32">                     parent=module['ns3::ObjectBase'],</span>
<span class="ansi32">+</span><span class="ansi32">                     memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('Object', import_from_module='ns.core', parent=module['ns3::SimpleRefCount&lt; ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter &gt;'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('TypeId', import_from_module='ns.core')</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('AttributeValue', import_from_module='ns.core')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('NodeContainer', import_from_module='ns.network')</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('Node', import_from_module='ns.network', parent=module['ns3::Object'])</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('ApplicationContainer', import_from_module='ns.network')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2017-9-16, should state before use</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('empty', import_from_module='ns.core')</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_cpp_namespace('empty')</span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2017-9-16 for tracer, refer to same file in ubuntu 12.04, should state before use</span>
<span class="ansi32">+</span><span class="ansi32">    root_module=module.get_root()</span>
<span class="ansi32">+</span><span class="ansi32">    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt; &gt; [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::ndn::AppDelayTracer', 'ns3::empty', 'ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt;'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))</span>
<span class="ansi32">+</span><span class="ansi32">    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt; &gt; [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::ndn::CsTracer', 'ns3::empty', 'ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt;'], parent=module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))</span>
<span class="ansi32">+</span><span class="ansi32">    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt; &gt; [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::ndn::L3Tracer', 'ns3::empty', 'ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt;'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))</span>
<span class="ansi32">+</span><span class="ansi32">    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::L2Tracer&gt; &gt; [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::L2Tracer', 'ns3::empty', 'ns3::DefaultDeleter&lt;ns3::L2Tracer&gt;'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    ## if not state follow sentence, the method InstallAll of CsTracer will not appear because of the type ns3::Time can not be recognized</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    ## nstime.h (module 'core'): ns3::Time [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('Time', import_from_module='ns.core')</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    ## names.h (module 'core'): ns3::Names [class]</span>
<span class="ansi32">+</span><span class="ansi32">    #module.add_cpp_namespace('Names')</span>
<span class="ansi32">+</span><span class="ansi32">    #module.add_class('Names', import_from_module='ns.core')</span>
<span class="ansi32">+</span><span class="ansi32">    #Module('Names',cpp_namespace="::Names")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_ndn(module):</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('StackHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('FibHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('StrategyChoiceHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('AppHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('GlobalRoutingHelper')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('L3Protocol', parent=module.get_root()['ns3::Object'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Name')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Interest')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Data')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Face', memory_policy=StdSharedPtr('ns3::ndn::Face'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_name(module):</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Component')</span>
<span class="ansi32">+</span><span class="ansi32">        reg_name(module.add_cpp_namespace('name'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_nfd(module):</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Forwarder', memory_policy=StdSharedPtr('::ns3::ndn::nfd::Forwarder'), is_singleton=True)</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Fib')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Pit')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Cs')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('FaceTable')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Face')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            def reg_fib(module):</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('Entry')#, memory_policy=StdSharedPtr('ns3::ndn::nfd::fib::Entry'))</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('NextHop')</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('NextHopList')</span>
<span class="ansi32">+</span><span class="ansi32">            reg_fib(module.add_cpp_namespace('fib'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            def reg_pit(module):</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('Entry')#, memory_policy=StdSharedPtr('ns3::ndn::nfd::pit::Entry'))</span>
<span class="ansi32">+</span><span class="ansi32">            reg_pit(module.add_cpp_namespace('pit'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            def reg_cs(module):</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('Entry')#, memory_policy=StdSharedPtr('ns3::ndn::nfd::cs::Entry'))</span>
<span class="ansi32">+</span><span class="ansi32">            reg_cs(module.add_cpp_namespace('cs'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        reg_nfd(module.add_cpp_namespace('nfd'))</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        #ZhangYu 2017-9-16 ------------------------Tracer---------------------</span>
<span class="ansi32">+</span><span class="ansi32">        root_module=module.get_root()</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('AppDelayTracer', parent=root_module['ns3::SimpleRefCount&lt; ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('CsTracer', parent=root_module['ns3::SimpleRefCount&lt; ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('L3Tracer', parent=root_module['ns3::SimpleRefCount&lt; ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('L3RateTracer', parent=root_module['ns3::ndn::L3Tracer'])</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-l3-aggregate-tracer.h (module 'ndnSIM'): ns3::ndn::L3AggregateTracer [class]</span>
<span class="ansi32">+</span><span class="ansi32">        #module.add_class('L3AggregateTracer', parent=root_module['ns3::ndn::L3Tracer'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    reg_ndn(module.add_cpp_namespace('ndn'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    ## l2-tracer.h (module 'ndnSIM'): ns3::L2Tracer [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('L2Tracer', parent=root_module['ns3::SimpleRefCount&lt; ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::L2Tracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi32">    ## l2-rate-tracer.h (module 'ndnSIM'): ns3::L2RateTracer [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('L2RateTracer', parent=root_module['ns3::L2Tracer'])</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2017-9-4, refer to the same file in ubuntu 12.04, also can see from http://ndnsim.net/2.3/doxygen/classns3_1_1AnnotatedTopologyReader.html</span>
<span class="ansi32">+</span><span class="ansi32">    # refer to scr/topology-read/modulegen_gcc_ILP32.py</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::TopologyReader', 'ns3::empty',</span>
<span class="ansi32">+</span><span class="ansi32">    'ns3::DefaultDeleter&lt;ns3::TopologyReader&gt;'], parent=module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref',</span>
<span class="ansi32">+</span><span class="ansi32">        peekref_method='GetReferenceCount'))</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('TopologyReader',allow_subclassing=True, import_from_module='ns.topology_read',parent=module['ns3::SimpleRefCount&lt; ns3::TopologyReader, ns3::empty, ns3::DefaultDeleter&lt;ns3::TopologyReader&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi32">    Module("TopologyReader",cpp_namespace="::TopologyReader")</span>
<span class="ansi32">+</span><span class="ansi32">    # Refer to the file in Ubuntu1204, annotated-topology-reader.h (module 'ndnSIM'): ns3::AnnotatedTopologyReader [class]</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('AnnotatedTopologyReader', allow_subclassing=True, parent=module['ns3::TopologyReader'])</span>
<span class="ansi32">+</span><span class="ansi32">    Module("AnnotatedTopologyReader",cpp_namespace="ns3::AnnotatedTopologyReader")</span>
<span class="ansi32">+</span><span class="ansi32">    # have the folowing sentence would make error of adding AnnotatedTopologyReader</span>
<span class="ansi32">+</span><span class="ansi32">    #module.add_cpp_namespace('AnnotatedTopologyReader')</span><span class="ansi41"> </span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def register_methods(root_module):</span>
<span class="ansi32">+</span><span class="ansi32">    reg_other_modules(root_module)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_stackhelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('ns3::Ptr&lt;ns3::Node&gt;', 'node')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('std::string const&amp;', 'nodeName')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('const ns3::NodeContainer&amp;', 'c')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll', retval('void'), [], is_const=True)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetDefaultRoutes', retval('void'), [param('bool', 'isEnabled', default_value='true')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetStackAttributes',</span>
<span class="ansi32">+</span><span class="ansi32">                       retval('void'),</span>
<span class="ansi32">+</span><span class="ansi32">                       [param('const std::string&amp;', 'attr1', default_value='""'), param('const std::string&amp;', 'value1', default_value='""'),</span>
<span class="ansi32">+</span><span class="ansi32">                        param('const std::string&amp;', 'attr2', default_value='""'), param('const std::string&amp;', 'value2', default_value='""'),</span>
<span class="ansi32">+</span><span class="ansi32">                        param('const std::string&amp;', 'attr3', default_value='""'), param('const std::string&amp;', 'value3', default_value='""'),</span>
<span class="ansi32">+</span><span class="ansi32">                        param('const std::string&amp;', 'attr4', default_value='""'), param('const std::string&amp;', 'value4', default_value='""')])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('setCsSize', retval('void'), [param('size_t', 'maxSize')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_stackhelper(root_module['ns3::ndn::StackHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_fibhelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('const std::string&amp;', 'nodeName'), param('const std::string&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('uint32_t', 'faceId'), param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'node'), param('const ns3::ndn::Name&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('uint32_t', 'faceId'), param('int32_t', 'metric')</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'node'), param('const ns3::ndn::Name&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('std::shared_ptr&lt;ns3::ndn::Face&gt;', 'face'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'node'), param('const ns3::ndn::Name&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'otherNode'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('const std::string&amp;', 'nodeName'), param('const std::string&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('const std::string&amp;', 'otherNodeName'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_fibhelper(root_module['ns3::ndn::FibHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_strategychoicehelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('ns3::Ptr&lt;ns3::Node&gt;', 'node'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'name'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'strategy')], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('const ns3::NodeContainer&amp;', 'c'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'name'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'strategy')], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll', retval('void'), [param('const std::string&amp;', 'name'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                      param('const std::string&amp;', 'strategy')], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_strategychoicehelper(root_module['ns3::ndn::StrategyChoiceHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_apphelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const std::string&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetPrefix', 'void', [param('const std::string&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetAttribute', 'void', [param('std::string', 'name'), param('const ns3::AttributeValue&amp;', 'value')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'ns3::ApplicationContainer', [param('ns3::NodeContainer', 'c')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'ns3::ApplicationContainer', [param('ns3::Ptr&lt;ns3::Node&gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'ns3::ApplicationContainer', [param('std::string', 'nodeName')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_apphelper(root_module['ns3::ndn::AppHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_GlobalRoutingHelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'void', [param('ns3::Ptr&lt;ns3::Node&gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'void', [param('const ns3::NodeContainer&amp;', 'nodes')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOrigin', 'void', [param('const std::string&amp;', 'prefix'), param('ns3::Ptr&lt;ns3::Node&gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOrigin', 'void', [param('const std::string&amp;', 'prefix'), param('const std::string&amp;', 'nodeName')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOrigins', 'void', [param('const std::string&amp;', 'prefix'), param('const ns3::NodeContainer&amp;', 'nodes')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOriginsForAll', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('CalculateRoutes', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('CalculateAllPossibleRoutes', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">        # if use  std::int32_t then there will arise error: object has no attribute CalculateNoCommLinkMultiPathRoutes</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('CalculateNoCommLinkMultiPathRoutes','void',[param('int32_t', 'multipathNumber')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('CalculateNoCommLinkMultiPathRoutesPairFirst','void',[])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('addRouteHop','void',[param('const std::string&amp;','edgeStart'),param('const std::string&amp;','prefix'),param('const std::string&amp;','edgeEnd'),param('int','metric')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('addRouteHop','void',[param('const std::string&amp;','edgeStart'),param('const std::string&amp;','prefix'),param('const std::string&amp;','edgeEnd'),param('int','metric'),param('double','probability')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_GlobalRoutingHelper(root_module['ns3::ndn::GlobalRoutingHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Name(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        for op in ['==', '!=', '&lt;', '&lt;=', '&gt;', '&gt;=']:</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_binary_comparison_operator(op)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::name::Component&amp;'),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::Name&amp;', 'other')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const std::string&amp;', 'url')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('append', 'ns3::ndn::Name &amp;', [param('const ns3::ndn::name::Component&amp;', 'comp')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('get', 'const ns3::ndn::name::Component&amp;', [param('int', 'index')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getPrefix', 'ns3::ndn::Name', [param('size_t', 'len')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', 'size_t', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('toUri', retval('std::string'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Name(root_module, root_module['ns3::ndn::Name'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NameComponent(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        for op in ['==', '!=', '&lt;', '&lt;=', '&gt;', '&gt;=']:</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_binary_comparison_operator(op)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::name::Component&amp;', 'arg0')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('fromNumber', 'ns3::ndn::name::Component', [param('uint64_t', 'number')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('fromNumberWithMarker', 'ns3::ndn::name::Component', [param('uint64_t', 'number'), param('unsigned char', 'marker')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('fromEscapedString', 'ns3::ndn::name::Component', [param('const std::string&amp;', 'uri')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NameComponent(root_module['ns3::ndn::name::Component'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Interest(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::Interest&amp;', 'interest')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Interest(root_module['ns3::ndn::Interest'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Data(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::Data&amp;', 'data')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Data(root_module['ns3::ndn::Data'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #########################################################################################</span>
<span class="ansi32">+</span><span class="ansi32">    ## Interface to NFD</span>
<span class="ansi32">+</span><span class="ansi32">    #########################################################################################</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def register_L3Protocol(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getL3Protocol', 'ns3::Ptr&lt;ns3::ndn::L3Protocol&gt;', [param('ns3::Ptr&lt;ns3::Object&gt;', 'node')], is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getForwarder', 'std::shared_ptr&lt;ns3::ndn::nfd::Forwarder&gt;', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getFaceTable', retval('const ns3::ndn::nfd::FaceTable&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    register_L3Protocol(root_module['ns3::ndn::L3Protocol'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    # shared_ptr&lt;Face&gt;</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Face(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getId', retval('int64_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Face(root_module['ns3::ndn::Face'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    # without shared_ptr</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_nfdFace(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getId', retval('int64_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_nfdFace(root_module['ns3::ndn::nfd::Face'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdForwarder(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getFib', retval('const ns3::ndn::nfd::Fib&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getPit', retval('const ns3::ndn::nfd::Pit&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getCs', retval('const ns3::ndn::nfd::Cs&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdForwarder(root_module['ns3::ndn::nfd::Forwarder'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span><span class="ansi32">    #### FIB ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdFib(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::fib::Entry&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        # The following is not supported</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findLongestPrefixMatch', retval('std::shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const ns3::ndn::Name&amp;', 'prefix')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findExactMatch', retval('std::shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const ns3::ndn::Name&amp;', 'prefix')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findLongestPrefixMatch', retval('shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const pit::Entry&amp;', 'pitEntry')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findLongestPrefixMatch', retval('shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const measurements::Entry&amp;', 'measurementsEntry')], is_const=True)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('insert', retval('std::pair&lt;std::shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;, bool&gt;'), [param('const ns3::ndn::Name&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('erase', retval('void'), [param('const ns3::ndn::Name&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('erase', retval('void'), [param('const ns3::ndn::nfd::fib::Entry&amp;', 'entry')])</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('removeNextHopFromAllEntries', retval('void'), [param('std::shared_ptr&lt;ns3::ndn::Face&gt;', 'face')])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_Entry(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getPrefix', 'const ns3::ndn::Name&amp;', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getNextHops', retval('const ns3::ndn::nfd::fib::NextHopList&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('hasNextHops', 'bool', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_Entry(root_module['ns3::ndn::nfd::fib::Entry'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_NextHop(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_constructor([param('const ns3::ndn::Face&amp;', 'face')])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_function_as_method('getFaceFromFibNextHop', 'std::shared_ptr&lt;ns3::ndn::Face&gt;',</span>
<span class="ansi32">+</span><span class="ansi32">                                       [param('const ns3::ndn::nfd::fib::NextHop&amp;', 'obj')],</span>
<span class="ansi32">+</span><span class="ansi32">                                       custom_name='getFace')</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('setCost', 'void', [param('uint64_t', 'cost')])</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getCost', 'uint64_t', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_NextHop(root_module['ns3::ndn::nfd::fib::NextHop'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_NextHopList(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_container_traits(retval('const ns3::ndn::nfd::fib::NextHop&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                     begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span><span class="ansi32">        reg_NextHopList(root_module['ns3::ndn::nfd::fib::NextHopList'])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdFib(root_module, root_module['ns3::ndn::nfd::Fib'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### FIB ####</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span><span class="ansi32">    #### PIT ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdPit(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::pit::Entry&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_Entry(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getInterest', retval('const ns3::ndn::Interest&amp;'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getName', retval('const ns3::ndn::Name&amp;'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_Entry(root_module['ns3::ndn::nfd::pit::Entry'])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdPit(root_module, root_module['ns3::ndn::nfd::Pit'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### PIT ####</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span><span class="ansi32">    #### CS ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdCs(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::cs::Entry&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_Entry(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getName', retval('const ns3::ndn::Name&amp;'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_Entry(root_module['ns3::ndn::nfd::cs::Entry'])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdCs(root_module, root_module['ns3::ndn::nfd::Cs'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### CS ####</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    def reg_CsTracer(root_module,cls):</span>
<span class="ansi32">+</span><span class="ansi32">        #ZhangYu 2017-9-20 Delete some method, but not all the method delteted have been added successfully</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-cs-tracer.h (module 'ndnSIM'): ns3::ndn::CsTracer::CsTracer(ns3::ndn::CsTracer const &amp; arg0) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::ndn::CsTracer const &amp;', 'arg0')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-cs-tracer.h (module 'ndnSIM'): ns3::ndn::CsTracer::CsTracer(boost::shared_ptr&lt;std::ostream&gt; os, ns3::Ptr&lt;ns3::Node&gt; node) [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('boost::shared_ptr&lt; std::ostream &gt;', 'os'), param('ns3::Ptr&lt; ns3::Node &gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-cs-tracer.h (module 'ndnSIM'): ns3::ndn::CsTracer::CsTracer(boost::shared_ptr&lt;std::ostream&gt; os, std::string const &amp; node) [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('boost::shared_ptr&lt; std::ostream &gt;', 'os'), param('std::string const &amp;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-cs-tracer.h (module 'ndnSIM'): static void ns3::ndn::CsTracer::Destroy() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Destroy',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-cs-tracer.h (module 'ndnSIM'): static void ns3::ndn::CsTracer::InstallAll(std::string const &amp; file, ns3::Time averagingPeriod=ns3::Seconds( )) [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::string const &amp;', 'file'), param('ns3::Time', 'averagingPeriod', default_value='ns3::Seconds(0)')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-cs-tracer.h (module 'ndnSIM'): void ns3::ndn::CsTracer::Print(std::ostream &amp; os) const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">    reg_CsTracer(root_module, root_module['ns3::ndn::CsTracer'])</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    #ZhangYu 2017-9-16, it is neccessary for CsTracer</span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3SimpleRefCount__Ns3NdnCsTracer___methods(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt; &gt;::SimpleRefCount() [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt; &gt;::SimpleRefCount(ns3::SimpleRefCount&lt;ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt; &gt; const &amp; o) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::SimpleRefCount&lt; ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt; ns3::ndn::CsTracer &gt; &gt; const &amp;', 'o')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): static void ns3::SimpleRefCount&lt;ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt; &gt;::Cleanup() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        #ZhangYu 2018-4-3 raise error in ndnSIM2.5 version, so comment it</span>
<span class="ansi32">+</span><span class="ansi32">        #cls.add_method('Cleanup', 'void',[], is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3SimpleRefCount__Ns3NdnCsTracer___methods(root_module, root_module['ns3::SimpleRefCount&lt; ns3::ndn::CsTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::CsTracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    #ZhangYu 2017-9-20 for OtherTracer</span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3SimpleRefCount__Ns3NdnAppDelayTracer___methods(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt; &gt;::SimpleRefCount() [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt; &gt;::SimpleRefCount(ns3::SimpleRefCount&lt;ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt; &gt; const &amp; o) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::SimpleRefCount&lt; ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt; ns3::ndn::AppDelayTracer &gt; &gt; const &amp;', 'o')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): static void ns3::SimpleRefCount&lt;ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt; &gt;::Cleanup() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        #cls.add_method('Cleanup', 'void',[], is_static=True)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3SimpleRefCount__Ns3NdnAppDelayTracer___methods(root_module, root_module['ns3::SimpleRefCount&lt; ns3::ndn::AppDelayTracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::AppDelayTracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3NdnAppDelayTracer_methods(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-app-delay-tracer.h (module 'ndnSIM'): ns3::ndn::AppDelayTracer::AppDelayTracer(ns3::ndn::AppDelayTracer const &amp; arg0) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::ndn::AppDelayTracer const &amp;', 'arg0')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-app-delay-tracer.h (module 'ndnSIM'): ns3::ndn::AppDelayTracer::AppDelayTracer(boost::shared_ptr&lt;std::ostream&gt; os, ns3::Ptr&lt;ns3::Node&gt; node) [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('boost::shared_ptr&lt; std::ostream &gt;', 'os'), param('ns3::Ptr&lt; ns3::Node &gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-app-delay-tracer.h (module 'ndnSIM'): ns3::ndn::AppDelayTracer::AppDelayTracer(boost::shared_ptr&lt;std::ostream&gt; os, std::string const &amp; node) [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('boost::shared_ptr&lt; std::ostream &gt;', 'os'), param('std::string const &amp;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-app-delay-tracer.h (module 'ndnSIM'): static void ns3::ndn::AppDelayTracer::Destroy() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Destroy',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-app-delay-tracer.h (module 'ndnSIM'): static void ns3::ndn::AppDelayTracer::InstallAll(std::string const &amp; file) [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::string const &amp;', 'file')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3NdnAppDelayTracer_methods(root_module, root_module['ns3::ndn::AppDelayTracer'])</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3SimpleRefCount__Ns3NdnL3Tracer___methods(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt; &gt;::SimpleRefCount() [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt; &gt;::SimpleRefCount(ns3::SimpleRefCount&lt;ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt; &gt; const &amp; o) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::SimpleRefCount&lt; ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt; ns3::ndn::L3Tracer &gt; &gt; const &amp;', 'o')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): static void ns3::SimpleRefCount&lt;ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt; &gt;::Cleanup() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        #cls.add_method('Cleanup', 'void',[], is_static=True)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        return</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3SimpleRefCount__Ns3NdnL3Tracer___methods(root_module, root_module['ns3::SimpleRefCount&lt; ns3::ndn::L3Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::ndn::L3Tracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3NdnL3RateTracer_methods(root_module, cls):</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">        ## ndn-l3-rate-tracer.h (module 'ndnSIM'): static void ns3::ndn::L3RateTracer::InstallAll(std::string const &amp; file, ns3::Time averagingPeriod=ns3::Seconds( )) [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::string const &amp;', 'file'), param('ns3::Time', 'averagingPeriod', default_value='ns3::Seconds(0)')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3NdnL3RateTracer_methods(root_module,root_module['ns3::ndn::L3RateTracer'])</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3SimpleRefCount__Ns3L2Tracer_Ns3Empty___methods(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::L2Tracer&gt; &gt;::SimpleRefCount() [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount&lt;ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::L2Tracer&gt; &gt;::SimpleRefCount(ns3::SimpleRefCount&lt;ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::L2Tracer&gt; &gt; const &amp; o) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::SimpleRefCount&lt; ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt; ns3::L2Tracer &gt; &gt; const &amp;', 'o')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## simple-ref-count.h (module 'core'): static void ns3::SimpleRefCount&lt;ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::L2Tracer&gt; &gt;::Cleanup() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        #cls.add_method('Cleanup', 'void',[], is_static=True)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        return</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3SimpleRefCount__Ns3L2Tracer_Ns3Empty___methods(root_module, root_module['ns3::SimpleRefCount&lt; ns3::L2Tracer, ns3::empty, ns3::DefaultDeleter&lt;ns3::L2Tracer&gt; &gt;'])</span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3L2Tracer_methods(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-tracer.h (module 'ndnSIM'): ns3::L2Tracer::L2Tracer(ns3::L2Tracer const &amp; arg0) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::L2Tracer const &amp;', 'arg0')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-tracer.h (module 'ndnSIM'): ns3::L2Tracer::L2Tracer(ns3::Ptr&lt;ns3::Node&gt; node) [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::Ptr&lt; ns3::Node &gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-tracer.h (module 'ndnSIM'): void ns3::L2Tracer::Connect() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Connect',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [])</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-tracer.h (module 'ndnSIM'): void ns3::L2Tracer::Drop(ns3::Ptr&lt;ns3::Packet const&gt; arg0) [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Drop',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('ns3::Ptr&lt; ns3::Packet const &gt;', 'arg0')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_pure_virtual=True, is_virtual=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-tracer.h (module 'ndnSIM'): void ns3::L2Tracer::Print(std::ostream &amp; os) const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Print',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::ostream &amp;', 'os')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_pure_virtual=True, is_const=True, is_virtual=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-tracer.h (module 'ndnSIM'): void ns3::L2Tracer::PrintHeader(std::ostream &amp; os) const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('PrintHeader',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::ostream &amp;', 'os')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_pure_virtual=True, is_const=True, is_virtual=True)</span>
<span class="ansi32">+</span><span class="ansi32">        return</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3L2Tracer_methods(root_module, root_module['ns3::L2Tracer'])</span>
<span class="ansi32">+</span><span class="ansi32">    def register_Ns3L2RateTracer_methods(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): ns3::L2RateTracer::L2RateTracer(ns3::L2RateTracer const &amp; arg0) [copy constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::L2RateTracer const &amp;', 'arg0')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): ns3::L2RateTracer::L2RateTracer(boost::shared_ptr&lt;std::ostream&gt; os, ns3::Ptr&lt;ns3::Node&gt; node) [constructor]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('boost::shared_ptr&lt; std::ostream &gt;', 'os'), param('ns3::Ptr&lt; ns3::Node &gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): static void ns3::L2RateTracer::Destroy() [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Destroy',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): void ns3::L2RateTracer::Drop(ns3::Ptr&lt;ns3::Packet const&gt; arg0) [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Drop',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('ns3::Ptr&lt; ns3::Packet const &gt;', 'arg0')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_virtual=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): static void ns3::L2RateTracer::InstallAll(std::string const &amp; file, ns3::Time averagingPeriod=ns3::Seconds( )) [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::string const &amp;', 'file'), param('ns3::Time', 'averagingPeriod', default_value='ns3::Seconds(0)')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): void ns3::L2RateTracer::Print(std::ostream &amp; os) const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Print',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::ostream &amp;', 'os')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_const=True, is_virtual=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): void ns3::L2RateTracer::PrintHeader(std::ostream &amp; os) const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('PrintHeader',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('std::ostream &amp;', 'os')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       is_const=True, is_virtual=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## l2-rate-tracer.h (module 'ndnSIM'): void ns3::L2RateTracer::SetAveragingPeriod(ns3::Time const &amp; period) [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetAveragingPeriod',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       'void',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                       [param('ns3::Time const &amp;', 'period')])</span>
<span class="ansi32">+</span><span class="ansi32">        return</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    register_Ns3L2RateTracer_methods(root_module, root_module['ns3::L2RateTracer'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    ###################</span>
<span class="ansi32">+</span><span class="ansi32">    #### FaceTable ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdFaceTable(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::Face&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdFaceTable(root_module, root_module['ns3::ndn::nfd::FaceTable'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### FaceTable ####</span>
<span class="ansi32">+</span><span class="ansi32">    ###################</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def reg_other_modules(root_module):</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_ApplicationContainer(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::ApplicationContainer', 'container')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_ApplicationContainer(root_module['ns3::ApplicationContainer'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2017-9-5 refer to same name file in Ubuntu1204</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    def reg_TopologyReader(cls):</span>
<span class="ansi32">+</span><span class="ansi32">         cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">         cls.add_method('SetFileName', 'void', [param('std::string const &amp;', 'fileName')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_TopologyReader(root_module['ns3::TopologyReader'])</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_AnnotatedTopologyReader(cls):</span>
<span class="ansi32">+</span><span class="ansi32">         cls.add_constructor([param('std::string const &amp;', 'path', default_value='""'), param('double', 'scale', default_value='1.0e+0')])</span>
<span class="ansi32">+</span><span class="ansi32">         cls.add_method('Read', param('const ns3::NodeContainer&amp;', 'nodes'), [])</span>
<span class="ansi32">+</span><span class="ansi32">         cls.add_method('ApplyOspfMetric','void',[])</span>
<span class="ansi32">+</span><span class="ansi32">         cls.add_method('FindNodeFromName','ns3::Ptr&lt; ns3::Node &gt;', [param('std::string const &amp;', 'name')])</span>
<span class="ansi32">+</span><span class="ansi32">         # ZhangYu 2018-1-28 for traffic load configure</span>
<span class="ansi32">+</span><span class="ansi32">         cls.add_method('GetNodeName','std::string',[param('ns3::Ptr&lt; ns3::Node &gt;','node')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_AnnotatedTopologyReader(root_module['ns3::AnnotatedTopologyReader'])</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2018-1-28 add for configure traffic load</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NodeContainer(root_module,cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## node-container.h (module 'network'): ns3::Ptr&lt;ns3::Node&gt; ns3::NodeContainer::Get(uint32_t i) const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Get',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   'ns3::Ptr&lt; ns3::Node &gt;',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   [param('uint32_t', 'i')],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## node-container.h (module 'network'): uint32_t ns3::NodeContainer::size() const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        # ZhangYu 2018-1-28, size() donot working, so add GetN</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   'uint32_t',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   [],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        ## node-container.h (module 'network'): uint32_t ns3::NodeContainer::GetN() const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('GetN',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   'uint32_t',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   [],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NodeContainer(root_module, root_module['ns3::NodeContainer'])</span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2018-1-28 maybe will be use in future</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Node(root_module,cls):</span>
<span class="ansi32">+</span><span class="ansi32">        ## node.h (module 'network'): uint32_t ns3::Node::GetId() const [member function]</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('GetId',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   'uint32_t',</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   [],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                   is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Node(root_module,root_module['ns3::Node'])</span>
<span class="ansi32">+</span><span class="ansi32">    return</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def register_functions(root_module):</span>
<span class="ansi32">+</span><span class="ansi32">    return</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def main():</span>
<span class="ansi32">+</span><span class="ansi32">    out = FileCodeSink(sys.stdout)</span>
<span class="ansi32">+</span><span class="ansi32">    root_module = module_init()</span>
<span class="ansi32">+</span><span class="ansi32">    register_types(root_module)</span>
<span class="ansi32">+</span><span class="ansi32">    register_methods(root_module)</span>
<span class="ansi32">+</span><span class="ansi32">    register_functions(root_module)</span>
<span class="ansi32">+</span><span class="ansi32">    root_module.generate(out)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">if __name__ == '__main__':</span>
<span class="ansi32">+</span><span class="ansi32">    main()</span>
<span class="ansi1">diff --git "a/bindings/modulegen__gcc_LP64.py.\347\275\221\347\253\231\344\270\213\350\275\275\347\232\204\345\216\237\345\247\213\346\226\207\344\273\26632\345\222\21464\346\230\257\344\270\200\346\240\267\347\232\204" "b/bindings/modulegen__gcc_LP64.py.\347\275\221\347\253\231\344\270\213\350\275\275\347\232\204\345\216\237\345\247\213\346\226\207\344\273\26632\345\222\21464\346\230\257\344\270\200\346\240\267\347\232\204"</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..6814816</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ "b/bindings/modulegen__gcc_LP64.py.\347\275\221\347\253\231\344\270\213\350\275\275\347\232\204\345\216\237\345\247\213\346\226\207\344\273\26632\345\222\21464\346\230\257\344\270\200\346\240\267\347\232\204"</span>
<span class="ansi36">@@ -0,0 +1,330 @@</span>
<span class="ansi32">+</span><span class="ansi32">from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">from pybindgen.typehandlers.smart_ptr import StdSharedPtr</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">from ns3_ptr import Ns3PtrMemoryPolicy</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">import pybindgen.settings</span>
<span class="ansi32">+</span><span class="ansi32">import warnings</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">import sys</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def module_init():</span>
<span class="ansi32">+</span><span class="ansi32">    root_module = Module('ns.ndnSIM', cpp_namespace='::ns3')</span>
<span class="ansi32">+</span><span class="ansi32">    return root_module</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def register_types(module):</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core',</span>
<span class="ansi32">+</span><span class="ansi32">                     template_parameters=['ns3::Object', 'ns3::ObjectBase', 'ns3::ObjectDeleter'],</span>
<span class="ansi32">+</span><span class="ansi32">                     parent=module['ns3::ObjectBase'],</span>
<span class="ansi32">+</span><span class="ansi32">                     memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('Object', import_from_module='ns.core', parent=module['ns3::SimpleRefCount&lt; ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter &gt;'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('TypeId', import_from_module='ns.core')</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('AttributeValue', import_from_module='ns.core')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('NodeContainer', import_from_module='ns.network')</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('Node', import_from_module='ns.network', parent=module['ns3::Object'])</span>
<span class="ansi32">+</span><span class="ansi32">    module.add_class('ApplicationContainer', import_from_module='ns.network')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_ndn(module):</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('StackHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('FibHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('StrategyChoiceHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('AppHelper')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('GlobalRoutingHelper')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('L3Protocol', parent=module.get_root()['ns3::Object'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Name')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Interest')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Data')</span>
<span class="ansi32">+</span><span class="ansi32">        module.add_class('Face', memory_policy=StdSharedPtr('ns3::ndn::Face'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_name(module):</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Component')</span>
<span class="ansi32">+</span><span class="ansi32">        reg_name(module.add_cpp_namespace('name'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_nfd(module):</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Forwarder', memory_policy=StdSharedPtr('::ns3::ndn::nfd::Forwarder'), is_singleton=True)</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Fib')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Pit')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Cs')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('FaceTable')</span>
<span class="ansi32">+</span><span class="ansi32">            module.add_class('Face')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            def reg_fib(module):</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('Entry')#, memory_policy=StdSharedPtr('ns3::ndn::nfd::fib::Entry'))</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('NextHop')</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('NextHopList')</span>
<span class="ansi32">+</span><span class="ansi32">            reg_fib(module.add_cpp_namespace('fib'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            def reg_pit(module):</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('Entry')#, memory_policy=StdSharedPtr('ns3::ndn::nfd::pit::Entry'))</span>
<span class="ansi32">+</span><span class="ansi32">            reg_pit(module.add_cpp_namespace('pit'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            def reg_cs(module):</span>
<span class="ansi32">+</span><span class="ansi32">                module.add_class('Entry')#, memory_policy=StdSharedPtr('ns3::ndn::nfd::cs::Entry'))</span>
<span class="ansi32">+</span><span class="ansi32">            reg_cs(module.add_cpp_namespace('cs'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        reg_nfd(module.add_cpp_namespace('nfd'))</span>
<span class="ansi32">+</span><span class="ansi32">    reg_ndn(module.add_cpp_namespace('ndn'))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def register_methods(root_module):</span>
<span class="ansi32">+</span><span class="ansi32">    reg_other_modules(root_module)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_stackhelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('ns3::Ptr&lt;ns3::Node&gt;', 'node')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('std::string const&amp;', 'nodeName')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('const ns3::NodeContainer&amp;', 'c')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll', retval('void'), [], is_const=True)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetDefaultRoutes', retval('void'), [param('bool', 'isEnabled', default_value='true')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetStackAttributes',</span>
<span class="ansi32">+</span><span class="ansi32">                       retval('void'),</span>
<span class="ansi32">+</span><span class="ansi32">                       [param('const std::string&amp;', 'attr1', default_value='""'), param('const std::string&amp;', 'value1', default_value='""'),</span>
<span class="ansi32">+</span><span class="ansi32">                        param('const std::string&amp;', 'attr2', default_value='""'), param('const std::string&amp;', 'value2', default_value='""'),</span>
<span class="ansi32">+</span><span class="ansi32">                        param('const std::string&amp;', 'attr3', default_value='""'), param('const std::string&amp;', 'value3', default_value='""'),</span>
<span class="ansi32">+</span><span class="ansi32">                        param('const std::string&amp;', 'attr4', default_value='""'), param('const std::string&amp;', 'value4', default_value='""')])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('setCsSize', retval('void'), [param('size_t', 'maxSize')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_stackhelper(root_module['ns3::ndn::StackHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_fibhelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('const std::string&amp;', 'nodeName'), param('const std::string&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('uint32_t', 'faceId'), param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'node'), param('const ns3::ndn::Name&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('uint32_t', 'faceId'), param('int32_t', 'metric')</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'node'), param('const ns3::ndn::Name&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('std::shared_ptr&lt;ns3::ndn::Face&gt;', 'face'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'node'), param('const ns3::ndn::Name&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('ns3::Ptr&lt;ns3::Node&gt;', 'otherNode'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddRoute', retval('void'), [</span>
<span class="ansi32">+</span><span class="ansi32">            param('const std::string&amp;', 'nodeName'), param('const std::string&amp;', 'prefix'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('const std::string&amp;', 'otherNodeName'),</span>
<span class="ansi32">+</span><span class="ansi32">            param('int32_t', 'metric'),</span>
<span class="ansi32">+</span><span class="ansi32">            ], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_fibhelper(root_module['ns3::ndn::FibHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_strategychoicehelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('ns3::Ptr&lt;ns3::Node&gt;', 'node'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'name'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'strategy')], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', retval('void'), [param('const ns3::NodeContainer&amp;', 'c'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'name'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                   param('const const std::string&amp;', 'strategy')], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll', retval('void'), [param('const std::string&amp;', 'name'),</span>
<span class="ansi32">+</span><span class="ansi32">                                                      param('const std::string&amp;', 'strategy')], is_const=True, is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_strategychoicehelper(root_module['ns3::ndn::StrategyChoiceHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_apphelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const std::string&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetPrefix', 'void', [param('const std::string&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('SetAttribute', 'void', [param('std::string', 'name'), param('const ns3::AttributeValue&amp;', 'value')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'ns3::ApplicationContainer', [param('ns3::NodeContainer', 'c')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'ns3::ApplicationContainer', [param('ns3::Ptr&lt;ns3::Node&gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'ns3::ApplicationContainer', [param('std::string', 'nodeName')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_apphelper(root_module['ns3::ndn::AppHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_GlobalRoutingHelper(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'void', [param('ns3::Ptr&lt;ns3::Node&gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('Install', 'void', [param('const ns3::NodeContainer&amp;', 'nodes')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('InstallAll', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOrigin', 'void', [param('const std::string&amp;', 'prefix'), param('ns3::Ptr&lt;ns3::Node&gt;', 'node')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOrigin', 'void', [param('const std::string&amp;', 'prefix'), param('const std::string&amp;', 'nodeName')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOrigins', 'void', [param('const std::string&amp;', 'prefix'), param('const ns3::NodeContainer&amp;', 'nodes')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('AddOriginsForAll', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('CalculateRoutes', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('CalculateAllPossibleRoutes', 'void', [])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_GlobalRoutingHelper(root_module['ns3::ndn::GlobalRoutingHelper'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Name(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        for op in ['==', '!=', '&lt;', '&lt;=', '&gt;', '&gt;=']:</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_binary_comparison_operator(op)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::name::Component&amp;'),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::Name&amp;', 'other')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const std::string&amp;', 'url')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('append', 'ns3::ndn::Name &amp;', [param('const ns3::ndn::name::Component&amp;', 'comp')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('get', 'const ns3::ndn::name::Component&amp;', [param('int', 'index')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getPrefix', 'ns3::ndn::Name', [param('size_t', 'len')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', 'size_t', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('toUri', retval('std::string'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Name(root_module, root_module['ns3::ndn::Name'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NameComponent(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        for op in ['==', '!=', '&lt;', '&lt;=', '&gt;', '&gt;=']:</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_binary_comparison_operator(op)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::name::Component&amp;', 'arg0')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('fromNumber', 'ns3::ndn::name::Component', [param('uint64_t', 'number')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('fromNumberWithMarker', 'ns3::ndn::name::Component', [param('uint64_t', 'number'), param('unsigned char', 'marker')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('fromEscapedString', 'ns3::ndn::name::Component', [param('const std::string&amp;', 'uri')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NameComponent(root_module['ns3::ndn::name::Component'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Interest(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::Interest&amp;', 'interest')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Interest(root_module['ns3::ndn::Interest'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Data(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('const ns3::ndn::Data&amp;', 'data')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Data(root_module['ns3::ndn::Data'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #########################################################################################</span>
<span class="ansi32">+</span><span class="ansi32">    ## Interface to NFD</span>
<span class="ansi32">+</span><span class="ansi32">    #########################################################################################</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def register_L3Protocol(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getL3Protocol', 'ns3::Ptr&lt;ns3::ndn::L3Protocol&gt;', [param('ns3::Ptr&lt;ns3::Object&gt;', 'node')], is_static=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getForwarder', 'std::shared_ptr&lt;ns3::ndn::nfd::Forwarder&gt;', [])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getFaceTable', retval('const ns3::ndn::nfd::FaceTable&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    register_L3Protocol(root_module['ns3::ndn::L3Protocol'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    # shared_ptr&lt;Face&gt;</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_Face(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getId', retval('int64_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_Face(root_module['ns3::ndn::Face'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    # without shared_ptr</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_nfdFace(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_output_stream_operator()</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getId', retval('int64_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_nfdFace(root_module['ns3::ndn::nfd::Face'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdForwarder(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getFib', retval('const ns3::ndn::nfd::Fib&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getPit', retval('const ns3::ndn::nfd::Pit&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('getCs', retval('const ns3::ndn::nfd::Cs&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdForwarder(root_module['ns3::ndn::nfd::Forwarder'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span><span class="ansi32">    #### FIB ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdFib(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::fib::Entry&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        # The following is not supported</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findLongestPrefixMatch', retval('std::shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const ns3::ndn::Name&amp;', 'prefix')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findExactMatch', retval('std::shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const ns3::ndn::Name&amp;', 'prefix')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findLongestPrefixMatch', retval('shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const pit::Entry&amp;', 'pitEntry')], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('findLongestPrefixMatch', retval('shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;'),</span>
<span class="ansi32">+</span><span class="ansi32">        #                [param('const measurements::Entry&amp;', 'measurementsEntry')], is_const=True)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('insert', retval('std::pair&lt;std::shared_ptr&lt;ns3::ndn::nfd::fib::Entry&gt;, bool&gt;'), [param('const ns3::ndn::Name&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('erase', retval('void'), [param('const ns3::ndn::Name&amp;', 'prefix')])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('erase', retval('void'), [param('const ns3::ndn::nfd::fib::Entry&amp;', 'entry')])</span>
<span class="ansi32">+</span><span class="ansi32">        # cls.add_method('removeNextHopFromAllEntries', retval('void'), [param('std::shared_ptr&lt;ns3::ndn::Face&gt;', 'face')])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_Entry(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getPrefix', 'const ns3::ndn::Name&amp;', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getNextHops', retval('const ns3::ndn::nfd::fib::NextHopList&amp;', caller_manages_return=False), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('hasNextHops', 'bool', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_Entry(root_module['ns3::ndn::nfd::fib::Entry'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_NextHop(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_constructor([param('const ns3::ndn::Face&amp;', 'face')])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_function_as_method('getFaceFromFibNextHop', 'std::shared_ptr&lt;ns3::ndn::Face&gt;',</span>
<span class="ansi32">+</span><span class="ansi32">                                       [param('const ns3::ndn::nfd::fib::NextHop&amp;', 'obj')],</span>
<span class="ansi32">+</span><span class="ansi32">                                       custom_name='getFace')</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('setCost', 'void', [param('uint64_t', 'cost')])</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getCost', 'uint64_t', [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_NextHop(root_module['ns3::ndn::nfd::fib::NextHop'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_NextHopList(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_container_traits(retval('const ns3::ndn::nfd::fib::NextHop&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                     begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span><span class="ansi32">        reg_NextHopList(root_module['ns3::ndn::nfd::fib::NextHopList'])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdFib(root_module, root_module['ns3::ndn::nfd::Fib'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### FIB ####</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span><span class="ansi32">    #### PIT ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdPit(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::pit::Entry&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_Entry(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getInterest', retval('const ns3::ndn::Interest&amp;'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getName', retval('const ns3::ndn::Name&amp;'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_Entry(root_module['ns3::ndn::nfd::pit::Entry'])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdPit(root_module, root_module['ns3::ndn::nfd::Pit'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### PIT ####</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span><span class="ansi32">    #### CS ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdCs(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::cs::Entry&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        def reg_Entry(cls):</span>
<span class="ansi32">+</span><span class="ansi32">            cls.add_method('getName', retval('const ns3::ndn::Name&amp;'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        reg_Entry(root_module['ns3::ndn::nfd::cs::Entry'])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdCs(root_module, root_module['ns3::ndn::nfd::Cs'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### CS ####</span>
<span class="ansi32">+</span><span class="ansi32">    #############</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    ###################</span>
<span class="ansi32">+</span><span class="ansi32">    #### FaceTable ####</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_NfdFaceTable(root_module, cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_method('size', retval('size_t'), [], is_const=True)</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_container_traits(retval('const ns3::ndn::nfd::Face&amp;', caller_manages_return=False),</span>
<span class="ansi32">+</span><span class="ansi32">                                 begin_method='begin', end_method='end', iterator_type='const_iterator')</span>
<span class="ansi32">+</span><span class="ansi32">    reg_NfdFaceTable(root_module, root_module['ns3::ndn::nfd::FaceTable'])</span>
<span class="ansi32">+</span><span class="ansi32">    #### FaceTable ####</span>
<span class="ansi32">+</span><span class="ansi32">    ###################</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def reg_other_modules(root_module):</span>
<span class="ansi32">+</span><span class="ansi32">    def reg_ApplicationContainer(cls):</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([])</span>
<span class="ansi32">+</span><span class="ansi32">        cls.add_constructor([param('ns3::ApplicationContainer', 'container')])</span>
<span class="ansi32">+</span><span class="ansi32">    reg_ApplicationContainer(root_module['ns3::ApplicationContainer'])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def register_functions(root_module):</span>
<span class="ansi32">+</span><span class="ansi32">    return</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def main():</span>
<span class="ansi32">+</span><span class="ansi32">    out = FileCodeSink(sys.stdout)</span>
<span class="ansi32">+</span><span class="ansi32">    root_module = module_init()</span>
<span class="ansi32">+</span><span class="ansi32">    register_types(root_module)</span>
<span class="ansi32">+</span><span class="ansi32">    register_methods(root_module)</span>
<span class="ansi32">+</span><span class="ansi32">    register_functions(root_module)</span>
<span class="ansi32">+</span><span class="ansi32">    root_module.generate(out)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">if __name__ == '__main__':</span>
<span class="ansi32">+</span><span class="ansi32">    main()</span>
<span class="ansi1">diff --git a/diff.html b/diff.html</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..e69de29</span>
<span class="ansi1">diff --git a/examples/12Nodes-Iot-2.py b/examples/12Nodes-Iot-2.py</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..01bb80d</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/12Nodes-Iot-2.py</span>
<span class="ansi36">@@ -0,0 +1,278 @@</span>
<span class="ansi32">+</span><span class="ansi32">## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32"># 2017-9-2 ZhangYu-SCIP-Routing.py</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32">from ns.core import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.network import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point_layout import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.ndnSIM import *</span>
<span class="ansi32">+</span><span class="ansi32">import mintreeMFP</span>
<span class="ansi32">+</span><span class="ansi32">from ns.topology_read import TopologyReader</span>
<span class="ansi32">+</span><span class="ansi32">import visualizer</span>
<span class="ansi32">+</span><span class="ansi32">import math</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2019-7-14 为了Iot的更改，添加不同缓存策略的仿真结果，在仿真结果文件中添加缓存策略</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2018-1-26 添加了traffic split, randomized rounding。因为randomized rounding是需要路由计算的结果来分配的带宽的，一种方法是按照</span>
<span class="ansi32">+</span><span class="ansi32"># NDF Developer Guide的建议保存在PIT中，这里采用了较简单的做法，直接保存在该主程序中，然后传递给自定义的NDF Strategy中</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2017-9-6 改用Python脚本运行ndnSIM仿真</span>
<span class="ansi32">+</span><span class="ansi32">"""</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    PyBindGen在Ubuntu1204虚拟机中的是可以用的，但是ndnSIM2.0以后无论是1404的GCC4.8还是1604的GCC5.1都不能正常执行--apiscan</span>
<span class="ansi32">+</span><span class="ansi32">    所以放弃了自动生成，而是手工修改modulegen__gcc_ILP32来添加AnnotatedTopologyReader，运行命令如下：</span>
<span class="ansi32">+</span><span class="ansi32">    NS_LOG=ndn.GlobalRoutingHelper:ndn.Producer ./waf --pyrun="src/ndnSIM/examples/ndn-zhangyu-scip-routing.py --routingName='Flooding'"</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------命令行参数----------------</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import ArgumentParser</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import RawDescriptionHelpFormatter</span>
<span class="ansi32">+</span><span class="ansi32"># Setup argument parser</span>
<span class="ansi32">+</span><span class="ansi32">parser = ArgumentParser(description="./waf --pyrun=ndn-zhangyu-scip-routing.py", formatter_class=RawDescriptionHelpFormatter)</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--InterestsPerSec", type=str,</span>
<span class="ansi32">+</span><span class="ansi32">                    default="300", help="Interests emit by consumer per second")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--simulationSpan", type=int,</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default=200, help="Simulation span time by seconds")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--routingName", type=str, choices=["Flooding","BestRoute","k-shortest-2","k-shortest-3","MultiPathPairFirst",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "SCIP","pyMultiPathPairFirst","pyFlooding","pyBestRoute","pyk-shortest-2",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortest-3","pyFloodingwithRestore","pyBestRoutewithRestore",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortestwithRestore-2","pyk-shortestwithRestore-3","debug"],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default="MultiPathPairFirst",</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    help="could be Flooding, BestRoute, MultiPath, MultiPathPairFirst")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--recordsNumber",type=int,default=100,help="total number of records in trace file")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--vis",action="store_true",default=False)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">args=parser.parse_args()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">manualAssign=False</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------仿真拓扑----------------</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="topo-for-CompareMultiPath.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="5Nodes-Debug.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topoFileName="12Nodes-3-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="100Nodes-5-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader=AnnotatedTopologyReader("",0.2)</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.SetFileName("src/ndnSIM/examples/topologies/"+topoFileName)</span>
<span class="ansi32">+</span><span class="ansi32">nodes=topologyReader.Read()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------协议加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper = ndn.StackHelper()</span>
<span class="ansi32">+</span><span class="ansi32">cachepolicy="Random"</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lru Least recently used (LRU) (default)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Fifo First-in-first-Out (FIFO)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lfu Least frequently used (LFU)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Random Random</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Nocache Policy that completely disables caching</span>
<span class="ansi32">+</span><span class="ansi32">if cachepolicy=="Nocache":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnHelper.SetOldContentStore("ns3::ndn::cs::Nocache","","","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    ndnHelper.SetOldContentStore("ns3::ndn::cs::" + cachepolicy,"MaxSize","200","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.InstallAll();</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.ApplyOspfMetric()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper = ndn.GlobalRoutingHelper()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper.InstallAll()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------业务加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">consumerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">producerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">if(manualAssign):</span>
<span class="ansi32">+</span><span class="ansi32">    consumerList=['Node0','Node1']</span>
<span class="ansi32">+</span><span class="ansi32">    producerList=['Node3','Node4']</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    K=int(math.floor(int(nodes.GetN())/2.0))</span>
<span class="ansi32">+</span><span class="ansi32">    for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">        consumerList.append(topologyReader.GetNodeName(nodes.Get(k)))</span>
<span class="ansi32">+</span><span class="ansi32">        producerList.append(topologyReader.GetNodeName(nodes.Get(k+K)))</span>
<span class="ansi32">+</span><span class="ansi32">if cachepolicy=="Nocache":</span>
<span class="ansi32">+</span><span class="ansi32">        cHelper = ndn.AppHelper("ns3::ndn::ConsumerCbr")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper= ndn.AppHelper("ns3::ndn::ConsumerZipfMandelbrot")</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper.SetAttribute("NumberOfContents", StringValue("1000")) # 1000 different contents，看ContentStore缓存多少</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Frequency", StringValue(args.InterestsPerSec))</span>
<span class="ansi32">+</span><span class="ansi32">#可以选择的有：</span>
<span class="ansi32">+</span><span class="ansi32">#"none": no randomization</span>
<span class="ansi32">+</span><span class="ansi32">#"uniform": uniform distribution in range (0, 1/Frequency)</span>
<span class="ansi32">+</span><span class="ansi32">#"exponential": exponential distribution with mean 1/Frequency</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Randomize", StringValue("exponential"))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">pHelper = ndn.AppHelper("ns3::ndn::Producer")</span>
<span class="ansi32">+</span><span class="ansi32">pHelper.SetAttribute("PayloadSize", StringValue("10240"));</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">2017-10-17 ZhangYu 考虑到多播时的FIB，把prefix改为跟producerName相关，而不是consumerName</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">    #if i==7:</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    print consumerList[i]</span>
<span class="ansi32">+</span><span class="ansi32">    App=cHelper.Install(topologyReader.FindNodeFromName(consumerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    #App.Start(Seconds(0.01*i));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.AddOrigin("/"+producerList[i], topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.Install(topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------路由和转发----------------</span>
<span class="ansi32">+</span><span class="ansi32"># Calculate and install FIBs</span>
<span class="ansi32">+</span><span class="ansi32">if args.routingName=="Flooding":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateAllPossibleRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="BestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/best-route")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="MultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutesPairFirst();</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="SCIP":</span>
<span class="ansi32">+</span><span class="ansi32">    lamb,routeList=mintreeMFP.caculatemaxConcurrentMFPRoute("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    为了能让数据分流到多条路径，使用概率转发，以前的多路径只是让Interest多副本转发，在统计时丢弃了重复的数据，应该在除了BestRoute和Flooding之外的所有其他多路径策略中设置概率转发</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyMultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    # 前面的各种算法是多路径重复发送数据，提高可靠性的，用来统计吞吐量是不合适的，因此使用了下面的使用概率转发实现业务分离的方式，为了简单全部使用Python实现</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculatenoCommLinkPairFirst("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是全部调用了caculateKshortest来实现的，这个实现中，所有计算路径的过程中，都会删除占用的边，全过程中没有复原拓扑，适用于静态业务</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFlooding":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是调用了caculateKshortestwithRestore，在计算完一轮K后，要复原拓扑，重新计算下一对源目的节点对，这更适合传统意义上的k-shortest path，</span>
<span class="ansi32">+</span><span class="ansi32"># 适合于动态业务，不能预先知道</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFloodingwithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoutewithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="debug":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node2",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node2","/Node4","Node4",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node1",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node1","/Node4","Node4",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    print "Unkown routingName, try again..."</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># # To access FIB, PIT, CS, uncomment the following lines</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># l3Protocol = ndn.L3Protocol.getL3Protocol(grid.GetNode(0,0))</span>
<span class="ansi32">+</span><span class="ansi32"># forwarder = l3Protocol.getForwarder()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># fib = forwarder.getFib()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of FIB (%d):" % fib.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in fib:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s:" % i.getPrefix()</span>
<span class="ansi32">+</span><span class="ansi32">#     for nh in i.getNextHops():</span>
<span class="ansi32">+</span><span class="ansi32">#         print "    - %s%d (cost: %d)" % (nh.getFace(), nh.getFace().getId(), nh.getCost())</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># pit = forwarder.getPit()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of PIT (%d):" % pit.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in pit:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># cs = forwarder.getCs()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of CS (%d):" % cs.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in cs:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------------------------------</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Stop(Seconds(args.simulationSpan))</span>
<span class="ansi32">+</span><span class="ansi32">#print dir(L2RateTracer)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果记录----------------</span>
<span class="ansi32">+</span><span class="ansi32">filename="-"+args.routingName.lower()+"-"+cachepolicy+"-"+str(args.InterestsPerSec)+".txt"</span>
<span class="ansi32">+</span><span class="ansi32">#filename=".txt"</span>
<span class="ansi32">+</span><span class="ansi32">TraceSpan=args.simulationSpan/args.recordsNumber;</span>
<span class="ansi32">+</span><span class="ansi32">if (TraceSpan&lt;1) :</span>
<span class="ansi32">+</span><span class="ansi32">    TraceSpan=1</span>
<span class="ansi32">+</span><span class="ansi32">#ndn.CsTracer.InstallAll("Results/cs-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.L3RateTracer.InstallAll("Results/rate-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.AppDelayTracer.InstallAll("Results/app-delays-trace"+filename)</span>
<span class="ansi32">+</span><span class="ansi32">L2RateTracer.InstallAll("Results/drop-trace"+filename,Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">if args.vis:</span>
<span class="ansi32">+</span><span class="ansi32">    visualizer.start()</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Run()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Destroy()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果处理----------------</span>
<span class="ansi32">+</span><span class="ansi32">import subprocess</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi1">diff --git a/examples/12Nodes-Iot.py b/examples/12Nodes-Iot.py</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..e0b0e33</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/12Nodes-Iot.py</span>
<span class="ansi36">@@ -0,0 +1,278 @@</span>
<span class="ansi32">+</span><span class="ansi32">## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32"># 2017-9-2 ZhangYu-SCIP-Routing.py</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32">from ns.core import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.network import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point_layout import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.ndnSIM import *</span>
<span class="ansi32">+</span><span class="ansi32">import mintreeMFP</span>
<span class="ansi32">+</span><span class="ansi32">from ns.topology_read import TopologyReader</span>
<span class="ansi32">+</span><span class="ansi32">import visualizer</span>
<span class="ansi32">+</span><span class="ansi32">import math</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2019-7-14 为了Iot的更改，添加不同缓存策略的仿真结果，在仿真结果文件中添加缓存策略</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2018-1-26 添加了traffic split, randomized rounding。因为randomized rounding是需要路由计算的结果来分配的带宽的，一种方法是按照</span>
<span class="ansi32">+</span><span class="ansi32"># NDF Developer Guide的建议保存在PIT中，这里采用了较简单的做法，直接保存在该主程序中，然后传递给自定义的NDF Strategy中</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2017-9-6 改用Python脚本运行ndnSIM仿真</span>
<span class="ansi32">+</span><span class="ansi32">"""</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    PyBindGen在Ubuntu1204虚拟机中的是可以用的，但是ndnSIM2.0以后无论是1404的GCC4.8还是1604的GCC5.1都不能正常执行--apiscan</span>
<span class="ansi32">+</span><span class="ansi32">    所以放弃了自动生成，而是手工修改modulegen__gcc_ILP32来添加AnnotatedTopologyReader，运行命令如下：</span>
<span class="ansi32">+</span><span class="ansi32">    NS_LOG=ndn.GlobalRoutingHelper:ndn.Producer ./waf --pyrun="src/ndnSIM/examples/ndn-zhangyu-scip-routing.py --routingName='Flooding'"</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------命令行参数----------------</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import ArgumentParser</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import RawDescriptionHelpFormatter</span>
<span class="ansi32">+</span><span class="ansi32"># Setup argument parser</span>
<span class="ansi32">+</span><span class="ansi32">parser = ArgumentParser(description="./waf --pyrun=ndn-zhangyu-scip-routing.py", formatter_class=RawDescriptionHelpFormatter)</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--InterestsPerSec", type=str,</span>
<span class="ansi32">+</span><span class="ansi32">                    default="300", help="Interests emit by consumer per second")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--simulationSpan", type=int,</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default=200, help="Simulation span time by seconds")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--routingName", type=str, choices=["Flooding","BestRoute","k-shortest-2","k-shortest-3","MultiPathPairFirst",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "SCIP","pyMultiPathPairFirst","pyFlooding","pyBestRoute","pyk-shortest-2",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortest-3","pyFloodingwithRestore","pyBestRoutewithRestore",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortestwithRestore-2","pyk-shortestwithRestore-3","debug"],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default="MultiPathPairFirst",</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    help="could be Flooding, BestRoute, MultiPath, MultiPathPairFirst")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--recordsNumber",type=int,default=100,help="total number of records in trace file")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--vis",action="store_true",default=False)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">args=parser.parse_args()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">manualAssign=False</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------仿真拓扑----------------</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="topo-for-CompareMultiPath.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="5Nodes-Debug.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topoFileName="12Nodes-3-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="100Nodes-5-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader=AnnotatedTopologyReader("",0.2)</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.SetFileName("src/ndnSIM/examples/topologies/"+topoFileName)</span>
<span class="ansi32">+</span><span class="ansi32">nodes=topologyReader.Read()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------协议加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper = ndn.StackHelper()</span>
<span class="ansi32">+</span><span class="ansi32">cachepolicy="Random"</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lru Least recently used (LRU) (default)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Fifo First-in-first-Out (FIFO)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lfu Least frequently used (LFU)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Random Random</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Nocache Policy that completely disables caching</span>
<span class="ansi32">+</span><span class="ansi32">if cachepolicy=="Nocache":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnHelper.SetOldContentStore("ns3::ndn::cs::Nocache","","","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    ndnHelper.SetOldContentStore("ns3::ndn::cs::" + cachepolicy,"MaxSize","500","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.InstallAll();</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.ApplyOspfMetric()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper = ndn.GlobalRoutingHelper()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper.InstallAll()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------业务加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">consumerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">producerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">if(manualAssign):</span>
<span class="ansi32">+</span><span class="ansi32">    consumerList=['Node0','Node1']</span>
<span class="ansi32">+</span><span class="ansi32">    producerList=['Node3','Node4']</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    K=int(math.floor(int(nodes.GetN())/2.0))</span>
<span class="ansi32">+</span><span class="ansi32">    for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">        consumerList.append(topologyReader.GetNodeName(nodes.Get(k)))</span>
<span class="ansi32">+</span><span class="ansi32">        producerList.append(topologyReader.GetNodeName(nodes.Get(k+K)))</span>
<span class="ansi32">+</span><span class="ansi32">if cachepolicy=="Nocache":</span>
<span class="ansi32">+</span><span class="ansi32">        cHelper = ndn.AppHelper("ns3::ndn::ConsumerCbr")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper= ndn.AppHelper("ns3::ndn::ConsumerZipfMandelbrot")</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper.SetAttribute("NumberOfContents", StringValue("1000")) # 1000 different contents，看ContentStore缓存多少</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Frequency", StringValue(args.InterestsPerSec))</span>
<span class="ansi32">+</span><span class="ansi32">#可以选择的有：</span>
<span class="ansi32">+</span><span class="ansi32">#"none": no randomization</span>
<span class="ansi32">+</span><span class="ansi32">#"uniform": uniform distribution in range (0, 1/Frequency)</span>
<span class="ansi32">+</span><span class="ansi32">#"exponential": exponential distribution with mean 1/Frequency</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Randomize", StringValue("exponential"))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">pHelper = ndn.AppHelper("ns3::ndn::Producer")</span>
<span class="ansi32">+</span><span class="ansi32">pHelper.SetAttribute("PayloadSize", StringValue("10240"));</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">2017-10-17 ZhangYu 考虑到多播时的FIB，把prefix改为跟producerName相关，而不是consumerName</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">    #if i==7:</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    print consumerList[i]</span>
<span class="ansi32">+</span><span class="ansi32">    App=cHelper.Install(topologyReader.FindNodeFromName(consumerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    #App.Start(Seconds(0.01*i));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.AddOrigin("/"+producerList[i], topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.Install(topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------路由和转发----------------</span>
<span class="ansi32">+</span><span class="ansi32"># Calculate and install FIBs</span>
<span class="ansi32">+</span><span class="ansi32">if args.routingName=="Flooding":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateAllPossibleRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="BestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/best-route")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="MultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutesPairFirst();</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="SCIP":</span>
<span class="ansi32">+</span><span class="ansi32">    lamb,routeList=mintreeMFP.caculatemaxConcurrentMFPRoute("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    为了能让数据分流到多条路径，使用概率转发，以前的多路径只是让Interest多副本转发，在统计时丢弃了重复的数据，应该在除了BestRoute和Flooding之外的所有其他多路径策略中设置概率转发</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyMultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    # 前面的各种算法是多路径重复发送数据，提高可靠性的，用来统计吞吐量是不合适的，因此使用了下面的使用概率转发实现业务分离的方式，为了简单全部使用Python实现</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculatenoCommLinkPairFirst("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是全部调用了caculateKshortest来实现的，这个实现中，所有计算路径的过程中，都会删除占用的边，全过程中没有复原拓扑，适用于静态业务</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFlooding":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是调用了caculateKshortestwithRestore，在计算完一轮K后，要复原拓扑，重新计算下一对源目的节点对，这更适合传统意义上的k-shortest path，</span>
<span class="ansi32">+</span><span class="ansi32"># 适合于动态业务，不能预先知道</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFloodingwithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoutewithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="debug":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node2",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node2","/Node4","Node4",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node1",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node1","/Node4","Node4",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    print "Unkown routingName, try again..."</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># # To access FIB, PIT, CS, uncomment the following lines</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># l3Protocol = ndn.L3Protocol.getL3Protocol(grid.GetNode(0,0))</span>
<span class="ansi32">+</span><span class="ansi32"># forwarder = l3Protocol.getForwarder()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># fib = forwarder.getFib()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of FIB (%d):" % fib.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in fib:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s:" % i.getPrefix()</span>
<span class="ansi32">+</span><span class="ansi32">#     for nh in i.getNextHops():</span>
<span class="ansi32">+</span><span class="ansi32">#         print "    - %s%d (cost: %d)" % (nh.getFace(), nh.getFace().getId(), nh.getCost())</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># pit = forwarder.getPit()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of PIT (%d):" % pit.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in pit:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># cs = forwarder.getCs()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of CS (%d):" % cs.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in cs:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------------------------------</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Stop(Seconds(args.simulationSpan))</span>
<span class="ansi32">+</span><span class="ansi32">#print dir(L2RateTracer)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果记录----------------</span>
<span class="ansi32">+</span><span class="ansi32">filename="-"+args.routingName.lower()+"-"+cachepolicy+"-"+str(args.InterestsPerSec)+".txt"</span>
<span class="ansi32">+</span><span class="ansi32">#filename=".txt"</span>
<span class="ansi32">+</span><span class="ansi32">TraceSpan=args.simulationSpan/args.recordsNumber;</span>
<span class="ansi32">+</span><span class="ansi32">if (TraceSpan&lt;1) :</span>
<span class="ansi32">+</span><span class="ansi32">    TraceSpan=1</span>
<span class="ansi32">+</span><span class="ansi32">#ndn.CsTracer.InstallAll("Results/cs-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.L3RateTracer.InstallAll("Results/rate-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.AppDelayTracer.InstallAll("Results/app-delays-trace"+filename)</span>
<span class="ansi32">+</span><span class="ansi32">L2RateTracer.InstallAll("Results/drop-trace"+filename,Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">if args.vis:</span>
<span class="ansi32">+</span><span class="ansi32">    visualizer.start()</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Run()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Destroy()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果处理----------------</span>
<span class="ansi32">+</span><span class="ansi32">import subprocess</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi1">diff --git a/examples/300Nodes-zhangyu-routing-2.py b/examples/300Nodes-zhangyu-routing-2.py</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..b9bdc1b</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/300Nodes-zhangyu-routing-2.py</span>
<span class="ansi36">@@ -0,0 +1,288 @@</span>
<span class="ansi32">+</span><span class="ansi32">## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32"># 2017-9-2 ZhangYu-SCIP-Routing.py</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32">from ns.core import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.network import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point_layout import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.ndnSIM import *</span>
<span class="ansi32">+</span><span class="ansi32">import mintreeMFP</span>
<span class="ansi32">+</span><span class="ansi32">from ns.topology_read import TopologyReader</span>
<span class="ansi32">+</span><span class="ansi32">import visualizer</span>
<span class="ansi32">+</span><span class="ansi32">import math</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2018-1-26 添加了traffic split, randomized rounding。因为randomized rounding是需要路由计算的结果来分配的带宽的，一种方法是按照</span>
<span class="ansi32">+</span><span class="ansi32"># NDF Developer Guide的建议保存在PIT中，这里采用了较简单的做法，直接保存在该主程序中，然后传递给自定义的NDF Strategy中</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2017-9-6 改用Python脚本运行ndnSIM仿真</span>
<span class="ansi32">+</span><span class="ansi32">"""</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    PyBindGen在Ubuntu1204虚拟机中的是可以用的，但是ndnSIM2.0以后无论是1404的GCC4.8还是1604的GCC5.1都不能正常执行--apiscan</span>
<span class="ansi32">+</span><span class="ansi32">    所以放弃了自动生成，而是手工修改modulegen__gcc_ILP32来添加AnnotatedTopologyReader，运行命令如下：</span>
<span class="ansi32">+</span><span class="ansi32">    NS_LOG=ndn.GlobalRoutingHelper:ndn.Producer ./waf --pyrun="src/ndnSIM/examples/ndn-zhangyu-scip-routing.py --routingName='Flooding'"</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------命令行参数----------------</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import ArgumentParser</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import RawDescriptionHelpFormatter</span>
<span class="ansi32">+</span><span class="ansi32"># Setup argument parser</span>
<span class="ansi32">+</span><span class="ansi32">parser = ArgumentParser(description="./waf --pyrun=ndn-zhangyu-scip-routing.py", formatter_class=RawDescriptionHelpFormatter)</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--InterestsPerSec", type=str,</span>
<span class="ansi32">+</span><span class="ansi32">                    default="300", help="Interests emit by consumer per second")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--simulationSpan", type=int,</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default=200, help="Simulation span time by seconds")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--routingName", type=str, choices=["Flooding","BestRoute","k-shortest-2","k-shortest-3","MultiPathPairFirst",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "SCIP","pyMultiPathPairFirst","pyFlooding","pyBestRoute","pyk-shortest-2",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortest-3","pyFloodingwithRestore","pyBestRoutewithRestore",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortestwithRestore-2","pyk-shortestwithRestore-3","pyk-shortestwithRestore-4","pyk-shortestwithRestore-5","debug"],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default="MultiPathPairFirst",</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    help="could be Flooding, BestRoute, MultiPath, MultiPathPairFirst")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--recordsNumber",type=int,default=20,help="total number of records in trace file")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--vis",action="store_true",default=False)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">args=parser.parse_args()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">manualAssign=False</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------仿真拓扑----------------</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="topo-for-CompareMultiPath.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="5Nodes-Debug.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="12Nodes-3-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topoFileName="300Nodes-5.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topoFileName="200Nodes-4.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader=AnnotatedTopologyReader("",0.2)</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.SetFileName("src/ndnSIM/examples/topologies/"+topoFileName)</span>
<span class="ansi32">+</span><span class="ansi32">nodes=topologyReader.Read()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------协议加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper = ndn.StackHelper()</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lru Least recently used (LRU) (default)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Fifo First-in-first-Out (FIFO)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lfu Least frequently used (LFU)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Random Random</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Nocache Policy that completely disables caching</span>
<span class="ansi32">+</span><span class="ansi32">#ndnHelper.SetOldContentStore("ns3::ndn::cs::Lru","MaxSize","100","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.SetOldContentStore("ns3::ndn::cs::Nocache","","","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.InstallAll();</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.ApplyOspfMetric()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper = ndn.GlobalRoutingHelper()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper.InstallAll()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------业务加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">consumerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">producerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">if(manualAssign):</span>
<span class="ansi32">+</span><span class="ansi32">    consumerList=['Node0','Node1']</span>
<span class="ansi32">+</span><span class="ansi32">    producerList=['Node3','Node4']</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    K=int(math.floor(int(nodes.GetN())/2.0))</span>
<span class="ansi32">+</span><span class="ansi32">    for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">        consumerList.append(topologyReader.GetNodeName(nodes.Get(k)))</span>
<span class="ansi32">+</span><span class="ansi32">        producerList.append(topologyReader.GetNodeName(nodes.Get(k+K)))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">cHelper = ndn.AppHelper("ns3::ndn::ConsumerCbr")</span>
<span class="ansi32">+</span><span class="ansi32">#cHelper= ndn.AppHelper("ns3::ndn::ConsumerZipfMandelbrot")</span>
<span class="ansi32">+</span><span class="ansi32">#cHelper.SetAttribute("NumberOfContents", StringValue("1000")) # 10 different contents</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Frequency", StringValue(args.InterestsPerSec))</span>
<span class="ansi32">+</span><span class="ansi32">#可以选择的有：</span>
<span class="ansi32">+</span><span class="ansi32">#"none": no randomization</span>
<span class="ansi32">+</span><span class="ansi32">#"uniform": uniform distribution in range (0, 1/Frequency)</span>
<span class="ansi32">+</span><span class="ansi32">#"exponential": exponential distribution with mean 1/Frequency</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Randomize", StringValue("exponential"))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">pHelper = ndn.AppHelper("ns3::ndn::Producer")</span>
<span class="ansi32">+</span><span class="ansi32">pHelper.SetAttribute("PayloadSize", StringValue("1024"));</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">2017-10-17 ZhangYu 考虑到多播时的FIB，把prefix改为跟producerName相关，而不是consumerName</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">    #if i==7:</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    print consumerList[i]</span>
<span class="ansi32">+</span><span class="ansi32">    App=cHelper.Install(topologyReader.FindNodeFromName(consumerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    #App.Start(Seconds(0.01*i));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.AddOrigin("/"+producerList[i], topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.Install(topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------路由和转发----------------</span>
<span class="ansi32">+</span><span class="ansi32"># Calculate and install FIBs</span>
<span class="ansi32">+</span><span class="ansi32">if args.routingName=="Flooding":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateAllPossibleRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="BestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/best-route")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="MultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutesPairFirst();</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="SCIP":</span>
<span class="ansi32">+</span><span class="ansi32">    lamb,routeList=mintreeMFP.caculatemaxConcurrentMFPRoute("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    为了能让数据分流到多条路径，使用概率转发，以前的多路径只是让Interest多副本转发，在统计时丢弃了重复的数据，应该在除了BestRoute和Flooding之外的所有其他多路径策略中设置概率转发</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyMultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    # 前面的各种算法是多路径重复发送数据，提高可靠性的，用来统计吞吐量是不合适的，因此使用了下面的使用概率转发实现业务分离的方式，为了简单全部使用Python实现</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculatenoCommLinkPairFirst("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是全部调用了caculateKshortest来实现的，这个实现中，所有计算路径的过程中，都会删除占用的边，全过程中没有复原拓扑，适用于静态业务</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFlooding":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-4":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,4)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是调用了caculateKshortestwithRestore，在计算完一轮K后，要复原拓扑，重新计算下一对源目的节点对，这更适合传统意义上的k-shortest path，</span>
<span class="ansi32">+</span><span class="ansi32"># 适合于动态业务，不能预先知道</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFloodingwithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoutewithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-4":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,4)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-5":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,5)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="debug":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node2",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node2","/Node4","Node4",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node1",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node1","/Node4","Node4",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    print "Unkown routingName, try again..."</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># # To access FIB, PIT, CS, uncomment the following lines</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># l3Protocol = ndn.L3Protocol.getL3Protocol(grid.GetNode(0,0))</span>
<span class="ansi32">+</span><span class="ansi32"># forwarder = l3Protocol.getForwarder()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># fib = forwarder.getFib()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of FIB (%d):" % fib.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in fib:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s:" % i.getPrefix()</span>
<span class="ansi32">+</span><span class="ansi32">#     for nh in i.getNextHops():</span>
<span class="ansi32">+</span><span class="ansi32">#         print "    - %s%d (cost: %d)" % (nh.getFace(), nh.getFace().getId(), nh.getCost())</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># pit = forwarder.getPit()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of PIT (%d):" % pit.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in pit:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># cs = forwarder.getCs()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of CS (%d):" % cs.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in cs:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------------------------------</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Stop(Seconds(args.simulationSpan))</span>
<span class="ansi32">+</span><span class="ansi32">#print dir(L2RateTracer)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果记录----------------</span>
<span class="ansi32">+</span><span class="ansi32">filename="-"+args.routingName.lower()+"-"+str(args.InterestsPerSec)+".txt"</span>
<span class="ansi32">+</span><span class="ansi32">#filename=".txt"</span>
<span class="ansi32">+</span><span class="ansi32">TraceSpan=args.simulationSpan/args.recordsNumber;</span>
<span class="ansi32">+</span><span class="ansi32">if (TraceSpan&lt;1) :</span>
<span class="ansi32">+</span><span class="ansi32">    TraceSpan=1</span>
<span class="ansi32">+</span><span class="ansi32">#ndn.CsTracer.InstallAll("Results/cs-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.L3RateTracer.InstallAll("Results/rate-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.AppDelayTracer.InstallAll("Results/app-delays-trace"+filename)</span>
<span class="ansi32">+</span><span class="ansi32">L2RateTracer.InstallAll("Results/drop-trace"+filename,Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">if args.vis:</span>
<span class="ansi32">+</span><span class="ansi32">    visualizer.start()</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Run()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Destroy()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果处理----------------</span>
<span class="ansi32">+</span><span class="ansi32">import subprocess</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi1">diff --git a/examples/300Nodes-zhangyu-routing.py b/examples/300Nodes-zhangyu-routing.py</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..eecbeba</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/300Nodes-zhangyu-routing.py</span>
<span class="ansi36">@@ -0,0 +1,288 @@</span>
<span class="ansi32">+</span><span class="ansi32">## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32"># 2017-9-2 ZhangYu-SCIP-Routing.py</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32">from ns.core import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.network import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point_layout import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.ndnSIM import *</span>
<span class="ansi32">+</span><span class="ansi32">import mintreeMFP</span>
<span class="ansi32">+</span><span class="ansi32">from ns.topology_read import TopologyReader</span>
<span class="ansi32">+</span><span class="ansi32">import visualizer</span>
<span class="ansi32">+</span><span class="ansi32">import math</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2018-1-26 添加了traffic split, randomized rounding。因为randomized rounding是需要路由计算的结果来分配的带宽的，一种方法是按照</span>
<span class="ansi32">+</span><span class="ansi32"># NDF Developer Guide的建议保存在PIT中，这里采用了较简单的做法，直接保存在该主程序中，然后传递给自定义的NDF Strategy中</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2017-9-6 改用Python脚本运行ndnSIM仿真</span>
<span class="ansi32">+</span><span class="ansi32">"""</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    PyBindGen在Ubuntu1204虚拟机中的是可以用的，但是ndnSIM2.0以后无论是1404的GCC4.8还是1604的GCC5.1都不能正常执行--apiscan</span>
<span class="ansi32">+</span><span class="ansi32">    所以放弃了自动生成，而是手工修改modulegen__gcc_ILP32来添加AnnotatedTopologyReader，运行命令如下：</span>
<span class="ansi32">+</span><span class="ansi32">    NS_LOG=ndn.GlobalRoutingHelper:ndn.Producer ./waf --pyrun="src/ndnSIM/examples/ndn-zhangyu-scip-routing.py --routingName='Flooding'"</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------命令行参数----------------</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import ArgumentParser</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import RawDescriptionHelpFormatter</span>
<span class="ansi32">+</span><span class="ansi32"># Setup argument parser</span>
<span class="ansi32">+</span><span class="ansi32">parser = ArgumentParser(description="./waf --pyrun=ndn-zhangyu-scip-routing.py", formatter_class=RawDescriptionHelpFormatter)</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--InterestsPerSec", type=str,</span>
<span class="ansi32">+</span><span class="ansi32">                    default="300", help="Interests emit by consumer per second")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--simulationSpan", type=int,</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default=200, help="Simulation span time by seconds")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--routingName", type=str, choices=["Flooding","BestRoute","k-shortest-2","k-shortest-3","MultiPathPairFirst",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "SCIP","pyMultiPathPairFirst","pyFlooding","pyBestRoute","pyk-shortest-2",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortest-3","pyFloodingwithRestore","pyBestRoutewithRestore",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortestwithRestore-2","pyk-shortestwithRestore-3","pyk-shortestwithRestore-4","pyk-shortestwithRestore-5","debug"],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default="MultiPathPairFirst",</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    help="could be Flooding, BestRoute, MultiPath, MultiPathPairFirst")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--recordsNumber",type=int,default=20,help="total number of records in trace file")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--vis",action="store_true",default=False)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">args=parser.parse_args()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">manualAssign=False</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------仿真拓扑----------------</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="topo-for-CompareMultiPath.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="5Nodes-Debug.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="12Nodes-3-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topoFileName="300Nodes-5.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="200Nodes-4.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader=AnnotatedTopologyReader("",0.2)</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.SetFileName("src/ndnSIM/examples/topologies/"+topoFileName)</span>
<span class="ansi32">+</span><span class="ansi32">nodes=topologyReader.Read()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------协议加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper = ndn.StackHelper()</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lru Least recently used (LRU) (default)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Fifo First-in-first-Out (FIFO)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lfu Least frequently used (LFU)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Random Random</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Nocache Policy that completely disables caching</span>
<span class="ansi32">+</span><span class="ansi32">#ndnHelper.SetOldContentStore("ns3::ndn::cs::Lru","MaxSize","100","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.SetOldContentStore("ns3::ndn::cs::Nocache","","","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.InstallAll();</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.ApplyOspfMetric()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper = ndn.GlobalRoutingHelper()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper.InstallAll()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------业务加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">consumerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">producerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">if(manualAssign):</span>
<span class="ansi32">+</span><span class="ansi32">    consumerList=['Node0','Node1']</span>
<span class="ansi32">+</span><span class="ansi32">    producerList=['Node3','Node4']</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    K=int(math.floor(int(nodes.GetN())/2.0))</span>
<span class="ansi32">+</span><span class="ansi32">    for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">        consumerList.append(topologyReader.GetNodeName(nodes.Get(k)))</span>
<span class="ansi32">+</span><span class="ansi32">        producerList.append(topologyReader.GetNodeName(nodes.Get(k+K)))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">cHelper = ndn.AppHelper("ns3::ndn::ConsumerCbr")</span>
<span class="ansi32">+</span><span class="ansi32">#cHelper= ndn.AppHelper("ns3::ndn::ConsumerZipfMandelbrot")</span>
<span class="ansi32">+</span><span class="ansi32">#cHelper.SetAttribute("NumberOfContents", StringValue("1000")) # 10 different contents</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Frequency", StringValue(args.InterestsPerSec))</span>
<span class="ansi32">+</span><span class="ansi32">#可以选择的有：</span>
<span class="ansi32">+</span><span class="ansi32">#"none": no randomization</span>
<span class="ansi32">+</span><span class="ansi32">#"uniform": uniform distribution in range (0, 1/Frequency)</span>
<span class="ansi32">+</span><span class="ansi32">#"exponential": exponential distribution with mean 1/Frequency</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Randomize", StringValue("exponential"))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">pHelper = ndn.AppHelper("ns3::ndn::Producer")</span>
<span class="ansi32">+</span><span class="ansi32">pHelper.SetAttribute("PayloadSize", StringValue("1024"));</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">2017-10-17 ZhangYu 考虑到多播时的FIB，把prefix改为跟producerName相关，而不是consumerName</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">    #if i==7:</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    print consumerList[i]</span>
<span class="ansi32">+</span><span class="ansi32">    App=cHelper.Install(topologyReader.FindNodeFromName(consumerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    #App.Start(Seconds(0.01*i));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.AddOrigin("/"+producerList[i], topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.Install(topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------路由和转发----------------</span>
<span class="ansi32">+</span><span class="ansi32"># Calculate and install FIBs</span>
<span class="ansi32">+</span><span class="ansi32">if args.routingName=="Flooding":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateAllPossibleRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="BestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/best-route")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="MultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutesPairFirst();</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="SCIP":</span>
<span class="ansi32">+</span><span class="ansi32">    lamb,routeList=mintreeMFP.caculatemaxConcurrentMFPRoute("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    为了能让数据分流到多条路径，使用概率转发，以前的多路径只是让Interest多副本转发，在统计时丢弃了重复的数据，应该在除了BestRoute和Flooding之外的所有其他多路径策略中设置概率转发</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyMultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    # 前面的各种算法是多路径重复发送数据，提高可靠性的，用来统计吞吐量是不合适的，因此使用了下面的使用概率转发实现业务分离的方式，为了简单全部使用Python实现</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculatenoCommLinkPairFirst("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是全部调用了caculateKshortest来实现的，这个实现中，所有计算路径的过程中，都会删除占用的边，全过程中没有复原拓扑，适用于静态业务</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFlooding":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-4":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,4)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是调用了caculateKshortestwithRestore，在计算完一轮K后，要复原拓扑，重新计算下一对源目的节点对，这更适合传统意义上的k-shortest path，</span>
<span class="ansi32">+</span><span class="ansi32"># 适合于动态业务，不能预先知道</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFloodingwithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoutewithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-4":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,4)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-5":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,5)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="debug":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node2",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node2","/Node4","Node4",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node1",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node1","/Node4","Node4",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    print "Unkown routingName, try again..."</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># # To access FIB, PIT, CS, uncomment the following lines</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># l3Protocol = ndn.L3Protocol.getL3Protocol(grid.GetNode(0,0))</span>
<span class="ansi32">+</span><span class="ansi32"># forwarder = l3Protocol.getForwarder()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># fib = forwarder.getFib()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of FIB (%d):" % fib.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in fib:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s:" % i.getPrefix()</span>
<span class="ansi32">+</span><span class="ansi32">#     for nh in i.getNextHops():</span>
<span class="ansi32">+</span><span class="ansi32">#         print "    - %s%d (cost: %d)" % (nh.getFace(), nh.getFace().getId(), nh.getCost())</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># pit = forwarder.getPit()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of PIT (%d):" % pit.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in pit:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># cs = forwarder.getCs()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of CS (%d):" % cs.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in cs:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------------------------------</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Stop(Seconds(args.simulationSpan))</span>
<span class="ansi32">+</span><span class="ansi32">#print dir(L2RateTracer)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果记录----------------</span>
<span class="ansi32">+</span><span class="ansi32">filename="-"+args.routingName.lower()+"-"+str(args.InterestsPerSec)+".txt"</span>
<span class="ansi32">+</span><span class="ansi32">#filename=".txt"</span>
<span class="ansi32">+</span><span class="ansi32">TraceSpan=args.simulationSpan/args.recordsNumber;</span>
<span class="ansi32">+</span><span class="ansi32">if (TraceSpan&lt;1) :</span>
<span class="ansi32">+</span><span class="ansi32">    TraceSpan=1</span>
<span class="ansi32">+</span><span class="ansi32">#ndn.CsTracer.InstallAll("Results/cs-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.L3RateTracer.InstallAll("Results/rate-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.AppDelayTracer.InstallAll("Results/app-delays-trace"+filename)</span>
<span class="ansi32">+</span><span class="ansi32">L2RateTracer.InstallAll("Results/drop-trace"+filename,Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">if args.vis:</span>
<span class="ansi32">+</span><span class="ansi32">    visualizer.start()</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Run()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Destroy()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果处理----------------</span>
<span class="ansi32">+</span><span class="ansi32">import subprocess</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi1">diff --git a/examples/5Nodes-zhangyu-routing.py b/examples/5Nodes-zhangyu-routing.py</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..e8422a2</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/5Nodes-zhangyu-routing.py</span>
<span class="ansi36">@@ -0,0 +1,273 @@</span>
<span class="ansi32">+</span><span class="ansi32">## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32"># 2017-9-2 ZhangYu-SCIP-Routing.py</span>
<span class="ansi32">+</span><span class="ansi32">#</span>
<span class="ansi32">+</span><span class="ansi32">from ns.core import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.network import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.point_to_point_layout import *</span>
<span class="ansi32">+</span><span class="ansi32">from ns.ndnSIM import *</span>
<span class="ansi32">+</span><span class="ansi32">import mintreeMFP</span>
<span class="ansi32">+</span><span class="ansi32">from ns.topology_read import TopologyReader</span>
<span class="ansi32">+</span><span class="ansi32">import visualizer</span>
<span class="ansi32">+</span><span class="ansi32">import math</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2018-1-26 添加了traffic split, randomized rounding。因为randomized rounding是需要路由计算的结果来分配的带宽的，一种方法是按照</span>
<span class="ansi32">+</span><span class="ansi32"># NDF Developer Guide的建议保存在PIT中，这里采用了较简单的做法，直接保存在该主程序中，然后传递给自定义的NDF Strategy中</span>
<span class="ansi32">+</span><span class="ansi32"># ZhangYu 2017-9-6 改用Python脚本运行ndnSIM仿真</span>
<span class="ansi32">+</span><span class="ansi32">"""</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    PyBindGen在Ubuntu1204虚拟机中的是可以用的，但是ndnSIM2.0以后无论是1404的GCC4.8还是1604的GCC5.1都不能正常执行--apiscan</span>
<span class="ansi32">+</span><span class="ansi32">    所以放弃了自动生成，而是手工修改modulegen__gcc_ILP32来添加AnnotatedTopologyReader，运行命令如下：</span>
<span class="ansi32">+</span><span class="ansi32">    NS_LOG=ndn.GlobalRoutingHelper:ndn.Producer ./waf --pyrun="src/ndnSIM/examples/ndn-zhangyu-scip-routing.py --routingName='Flooding'"</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------命令行参数----------------</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import ArgumentParser</span>
<span class="ansi32">+</span><span class="ansi32">from argparse import RawDescriptionHelpFormatter</span>
<span class="ansi32">+</span><span class="ansi32"># Setup argument parser</span>
<span class="ansi32">+</span><span class="ansi32">parser = ArgumentParser(description="./waf --pyrun=ndn-zhangyu-scip-routing.py", formatter_class=RawDescriptionHelpFormatter)</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--InterestsPerSec", type=str,</span>
<span class="ansi32">+</span><span class="ansi32">                    default="300", help="Interests emit by consumer per second")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--simulationSpan", type=int,</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default=200, help="Simulation span time by seconds")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--routingName", type=str, choices=["Flooding","BestRoute","k-shortest-2","k-shortest-3","MultiPathPairFirst",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "SCIP","pyMultiPathPairFirst","pyFlooding","pyBestRoute","pyk-shortest-2",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortest-3","pyFloodingwithRestore","pyBestRoutewithRestore",</span>
<span class="ansi32">+</span><span class="ansi32">                                                        "pyk-shortestwithRestore-2","pyk-shortestwithRestore-3","debug"],</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    default="MultiPathPairFirst",</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                    help="could be Flooding, BestRoute, MultiPath, MultiPathPairFirst")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--recordsNumber",type=int,default=100,help="total number of records in trace file")</span>
<span class="ansi32">+</span><span class="ansi32">parser.add_argument("--vis",action="store_true",default=False)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">args=parser.parse_args()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">manualAssign=False</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------仿真拓扑----------------</span>
<span class="ansi32">+</span><span class="ansi32">topoFileName="topo-for-CompareMultiPath.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="5Nodes-Debug.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="12Nodes-3-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">#topoFileName="100Nodes-5-1000.txt"</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader=AnnotatedTopologyReader("",0.2)</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.SetFileName("src/ndnSIM/examples/topologies/"+topoFileName)</span>
<span class="ansi32">+</span><span class="ansi32">nodes=topologyReader.Read()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------协议加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper = ndn.StackHelper()</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lru Least recently used (LRU) (default)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Fifo First-in-first-Out (FIFO)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Lfu Least frequently used (LFU)</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Random Random</span>
<span class="ansi32">+</span><span class="ansi32"># cs::Nocache Policy that completely disables caching</span>
<span class="ansi32">+</span><span class="ansi32">#ndnHelper.SetOldContentStore("ns3::ndn::cs::Lru","MaxSize","100","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.SetOldContentStore("ns3::ndn::cs::Nocache","","","","","","","","")</span>
<span class="ansi32">+</span><span class="ansi32">ndnHelper.InstallAll();</span>
<span class="ansi32">+</span><span class="ansi32">topologyReader.ApplyOspfMetric()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper = ndn.GlobalRoutingHelper()</span>
<span class="ansi32">+</span><span class="ansi32">ndnGlobalRoutingHelper.InstallAll()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------业务加载----------------</span>
<span class="ansi32">+</span><span class="ansi32">consumerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">producerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">if(manualAssign):</span>
<span class="ansi32">+</span><span class="ansi32">    consumerList=['Node0','Node1']</span>
<span class="ansi32">+</span><span class="ansi32">    producerList=['Node3','Node4']</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    K=int(math.floor(int(nodes.GetN())/2.0))</span>
<span class="ansi32">+</span><span class="ansi32">    for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">        consumerList.append(topologyReader.GetNodeName(nodes.Get(k)))</span>
<span class="ansi32">+</span><span class="ansi32">        producerList.append(topologyReader.GetNodeName(nodes.Get(k+K)))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">cHelper = ndn.AppHelper("ns3::ndn::ConsumerCbr")</span>
<span class="ansi32">+</span><span class="ansi32">#cHelper= ndn.AppHelper("ns3::ndn::ConsumerZipfMandelbrot")</span>
<span class="ansi32">+</span><span class="ansi32">#cHelper.SetAttribute("NumberOfContents", StringValue("1000")) # 10 different contents</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Frequency", StringValue(args.InterestsPerSec))</span>
<span class="ansi32">+</span><span class="ansi32">#可以选择的有：</span>
<span class="ansi32">+</span><span class="ansi32">#"none": no randomization</span>
<span class="ansi32">+</span><span class="ansi32">#"uniform": uniform distribution in range (0, 1/Frequency)</span>
<span class="ansi32">+</span><span class="ansi32">#"exponential": exponential distribution with mean 1/Frequency</span>
<span class="ansi32">+</span><span class="ansi32">cHelper.SetAttribute("Randomize", StringValue("exponential"))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">pHelper = ndn.AppHelper("ns3::ndn::Producer")</span>
<span class="ansi32">+</span><span class="ansi32">pHelper.SetAttribute("PayloadSize", StringValue("1024"));</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">2017-10-17 ZhangYu 考虑到多播时的FIB，把prefix改为跟producerName相关，而不是consumerName</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">    #if i==7:</span>
<span class="ansi32">+</span><span class="ansi32">    cHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    print(consumerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    App=cHelper.Install(topologyReader.FindNodeFromName(consumerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    #App.Start(Seconds(0.01*i));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.SetPrefix("/"+producerList[i])</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.AddOrigin("/"+producerList[i], topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    pHelper.Install(topologyReader.FindNodeFromName(producerList[i]))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------路由和转发----------------</span>
<span class="ansi32">+</span><span class="ansi32"># Calculate and install FIBs</span>
<span class="ansi32">+</span><span class="ansi32">if args.routingName=="Flooding":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateAllPossibleRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="BestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateRoutes()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/best-route")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="k-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutes(3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="MultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.CalculateNoCommLinkMultiPathRoutesPairFirst();</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/ncc")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="SCIP":</span>
<span class="ansi32">+</span><span class="ansi32">    lamb,routeList=mintreeMFP.caculatemaxConcurrentMFPRoute("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    为了能让数据分流到多条路径，使用概率转发，以前的多路径只是让Interest多副本转发，在统计时丢弃了重复的数据，应该在除了BestRoute和Flooding之外的所有其他多路径策略中设置概率转发</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyMultiPathPairFirst":</span>
<span class="ansi32">+</span><span class="ansi32">    # 前面的各种算法是多路径重复发送数据，提高可靠性的，用来统计吞吐量是不合适的，因此使用了下面的使用概率转发实现业务分离的方式，为了简单全部使用Python实现</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculatenoCommLinkPairFirst("/topologies/"+topoFileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">        print(routeList[i]['edgeStart']+','+routeList[i]['prefix']+','+routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是全部调用了caculateKshortest来实现的，这个实现中，所有计算路径的过程中，都会删除占用的边，全过程中没有复原拓扑，适用于静态业务</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFlooding":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoute":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortest-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortest("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32"># 下面是调用了caculateKshortestwithRestore，在计算完一轮K后，要复原拓扑，重新计算下一对源目的节点对，这更适合传统意义上的k-shortest path，</span>
<span class="ansi32">+</span><span class="ansi32"># 适合于动态业务，不能预先知道</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyFloodingwithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyBestRoutewithRestore":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-2":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="pyk-shortestwithRestore-3":</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=mintreeMFP.caculateKshortestwithRestore("/topologies/"+topoFileName,consumerList,producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(routeList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndnGlobalRoutingHelper.addRouteHop(routeList[i]['edgeStart'],routeList[i]['prefix'],routeList[i]['edgeEnd'],</span>
<span class="ansi32">+</span><span class="ansi32">                                           routeList[i]['cost'],routeList[i]['probability'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">elif args.routingName=="debug":</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node2",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node2","/Node4","Node4",1,0.1);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node0","/Node4","Node1",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    ndnGlobalRoutingHelper.addRouteHop("Node1","/Node4","Node4",1,0.9);</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(producerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        #ndn.StrategyChoiceHelper.InstallAll("/"+producerList[i], "/localhost/nfd/strategy/multicast")</span>
<span class="ansi32">+</span><span class="ansi32">        ndn.StrategyChoiceHelper.Install(topologyReader.FindNodeFromName(consumerList[i]), "/"+producerList[i], "/localhost/nfd/strategy/randomized-rounding")</span>
<span class="ansi32">+</span><span class="ansi32">else:</span>
<span class="ansi32">+</span><span class="ansi32">    print ("Unkown routingName, try again...")</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># # To access FIB, PIT, CS, uncomment the following lines</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># l3Protocol = ndn.L3Protocol.getL3Protocol(grid.GetNode(0,0))</span>
<span class="ansi32">+</span><span class="ansi32"># forwarder = l3Protocol.getForwarder()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># fib = forwarder.getFib()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of FIB (%d):" % fib.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in fib:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s:" % i.getPrefix()</span>
<span class="ansi32">+</span><span class="ansi32">#     for nh in i.getNextHops():</span>
<span class="ansi32">+</span><span class="ansi32">#         print "    - %s%d (cost: %d)" % (nh.getFace(), nh.getFace().getId(), nh.getCost())</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># pit = forwarder.getPit()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of PIT (%d):" % pit.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in pit:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># cs = forwarder.getCs()</span>
<span class="ansi32">+</span><span class="ansi32"># print "Contents of CS (%d):" % cs.size()</span>
<span class="ansi32">+</span><span class="ansi32"># for i in cs:</span>
<span class="ansi32">+</span><span class="ansi32">#     print " - %s" % i.getName()</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------------------------------</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Stop(Seconds(args.simulationSpan))</span>
<span class="ansi32">+</span><span class="ansi32">#print dir(L2RateTracer)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果记录----------------</span>
<span class="ansi32">+</span><span class="ansi32">filename="-"+args.routingName.lower()+"-"+str(args.InterestsPerSec)+".txt"</span>
<span class="ansi32">+</span><span class="ansi32">#filename=".txt"</span>
<span class="ansi32">+</span><span class="ansi32">TraceSpan=args.simulationSpan/args.recordsNumber;</span>
<span class="ansi32">+</span><span class="ansi32">if (TraceSpan&lt;1) :</span>
<span class="ansi32">+</span><span class="ansi32">    TraceSpan=1</span>
<span class="ansi32">+</span><span class="ansi32">#ndn.CsTracer.InstallAll("Results/cs-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.L3RateTracer.InstallAll("Results/rate-trace"+filename, Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">ndn.AppDelayTracer.InstallAll("Results/app-delays-trace"+filename)</span>
<span class="ansi32">+</span><span class="ansi32">L2RateTracer.InstallAll("Results/drop-trace"+filename,Seconds(TraceSpan))</span>
<span class="ansi32">+</span><span class="ansi32">if args.vis:</span>
<span class="ansi32">+</span><span class="ansi32">    visualizer.start()</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Run()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Simulator.Destroy()</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32"># ----------------结果处理----------------</span>
<span class="ansi32">+</span><span class="ansi32">import subprocess</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi1">diff --git a/examples/Fleischer.py b/examples/Fleischer.py</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..7678ee2</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/Fleischer.py</span>
<span class="ansi36">@@ -0,0 +1,184 @@</span>
<span class="ansi32">+</span><span class="ansi32"># _*_ coding: utf-8 _*_</span>
<span class="ansi32">+</span><span class="ansi32">from pyscipopt import Model, Conshdlr, quicksum , SCIP_RESULT, SCIP_PRESOLTIMING, SCIP_PROPTIMING, SCIP_PARAMSETTING, SCIP_PARAMEMPHASIS</span>
<span class="ansi32">+</span><span class="ansi32">from pyscipopt.scip import Expr, ExprCons, Term</span>
<span class="ansi32">+</span><span class="ansi32">import networkx as nx             #导入networkx包</span>
<span class="ansi32">+</span><span class="ansi32">from networkx.algorithms.flow import shortest_augmenting_path</span>
<span class="ansi32">+</span><span class="ansi32">import re</span>
<span class="ansi32">+</span><span class="ansi32">import numpy as np</span>
<span class="ansi32">+</span><span class="ansi32">import mpmath as mp</span>
<span class="ansi32">+</span><span class="ansi32">from mpmath import mpf</span>
<span class="ansi32">+</span><span class="ansi32">import sys, time</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">from collections import OrderedDict</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32">2018-6-10 编写高精度的Fleischer算法</span>
<span class="ansi32">+</span><span class="ansi32">因为Matlab eps精度不够，导致delta运算</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32">EPS = 1.e-6</span>
<span class="ansi32">+</span><span class="ansi32">manualAssign=False</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def readTopology(filename,cap=None):</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2018-1-28使用SCIP计算时，发现这里没有设置是否无向图， 而Matlab有这个选项</span>
<span class="ansi32">+</span><span class="ansi32">    isUndirectedGraph=True</span><span class="ansi41">   </span>
<span class="ansi32">+</span><span class="ansi32">    mark=["router\n","link\n"]</span>
<span class="ansi32">+</span><span class="ansi32">    try:</span>
<span class="ansi32">+</span><span class="ansi32">        filehandle = open(sys.path[0]+filename,'r')</span>
<span class="ansi32">+</span><span class="ansi32">    except:</span>
<span class="ansi32">+</span><span class="ansi32">        print("Could not open file " + sys.path[0]+filename)</span>
<span class="ansi32">+</span><span class="ansi32">        quit()</span>
<span class="ansi32">+</span><span class="ansi32">    filelines=filehandle.readlines()</span>
<span class="ansi32">+</span><span class="ansi32">    markPos=[]</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(mark)):</span>
<span class="ansi32">+</span><span class="ansi32">        markPos.append(filelines.index(mark[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    # read edges</span>
<span class="ansi32">+</span><span class="ansi32">    edge,node={},{}</span>
<span class="ansi32">+</span><span class="ansi32">    for aline in filelines[markPos[1]+1:]:</span>
<span class="ansi32">+</span><span class="ansi32">        if str(aline).startswith('#') | str(aline).startswith(' ') | str(aline).startswith('\n'):</span>
<span class="ansi32">+</span><span class="ansi32">            continue</span>
<span class="ansi32">+</span><span class="ansi32">        else:</span>
<span class="ansi32">+</span><span class="ansi32">            alineArray=str(aline).split()</span>
<span class="ansi32">+</span><span class="ansi32">            if cap is None:</span>
<span class="ansi32">+</span><span class="ansi32">                # 这里允许节点是诸如 UCLA-A这样的名字</span>
<span class="ansi32">+</span><span class="ansi32">                edge[str(alineArray[0]),</span>
<span class="ansi32">+</span><span class="ansi32">                     str(alineArray[1])]={'cap':re.findall(</span>
<span class="ansi32">+</span><span class="ansi32">                         "\d+",str(alineArray[2]))[0],'cost':re.findall("\d+",str(alineArray[3]))[0]}</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                edge[str(alineArray[0]),</span>
<span class="ansi32">+</span><span class="ansi32">                     str(alineArray[1])]={'cap':cap,'cost':re.findall("\d+",str(alineArray[3]))[0]}</span>
<span class="ansi32">+</span><span class="ansi32">            if isUndirectedGraph:</span>
<span class="ansi32">+</span><span class="ansi32">                edge[str(alineArray[1]),str(alineArray[0])]=edge[str(alineArray[0]),str(alineArray[1])]</span>
<span class="ansi32">+</span><span class="ansi41">                </span>
<span class="ansi32">+</span><span class="ansi32">    # read nodes. G can be get only by edges, we read nodes here because we need the nodes coordinate for drawing graph</span>
<span class="ansi32">+</span><span class="ansi32">    for aline in filelines[markPos[0]+1:markPos[1]]:</span>
<span class="ansi32">+</span><span class="ansi32">        if str(aline).startswith('#') | str(aline).startswith(' ') | str(aline).startswith('\n') | str(aline).startswith('\r'):</span>
<span class="ansi32">+</span><span class="ansi32">            continue</span>
<span class="ansi32">+</span><span class="ansi32">        else:</span>
<span class="ansi32">+</span><span class="ansi32">            alineArray=str(aline).split()</span>
<span class="ansi32">+</span><span class="ansi32">            node[str(alineArray[0])]=np.array(</span>
<span class="ansi32">+</span><span class="ansi32">                [int(re.findall("\d+", str(alineArray[3]))[0]),int(re.findall("\d+", str(alineArray[2]))[0])])</span>
<span class="ansi32">+</span><span class="ansi32">            #pos['1']=np.array([4,5])</span>
<span class="ansi32">+</span><span class="ansi41">            </span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    if __name__=="__main__":</span>
<span class="ansi32">+</span><span class="ansi32">        import matplotlib.pyplot as plt</span>
<span class="ansi32">+</span><span class="ansi32">        G=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_nodes_from(node)</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_edges_from(edge.keys())</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        # Draw nodes</span>
<span class="ansi32">+</span><span class="ansi32">        nx.draw_networkx_nodes(G, node,node_size=290, node_color='orange')</span>
<span class="ansi32">+</span><span class="ansi32">        nx.draw_networkx_labels(G, node,font_size=13, font_family='sans-serif')</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        # Draw edges</span>
<span class="ansi32">+</span><span class="ansi32">        nx.draw_networkx_edges(G,node, arrows=True,width=0.5, edge_color='g')</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        # Draw edge labels</span>
<span class="ansi32">+</span><span class="ansi32">        #edge_labels = dict([((u, v), d['label'])</span>
<span class="ansi32">+</span><span class="ansi32">        #                    for u, v, d in G.edges(data=True)])</span>
<span class="ansi32">+</span><span class="ansi32">        #nx.draw_networkx_edge_labels(G, pos,edge_labels=edge_labels)</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        plt.axis('off')  # 是否打开坐标系on/off</span>
<span class="ansi32">+</span><span class="ansi32">        plt.savefig("topology_graph.eps", format='eps')  # save as eps</span>
<span class="ansi32">+</span><span class="ansi32">        #plt.ion()</span>
<span class="ansi32">+</span><span class="ansi32">        #plt.pause(5)</span>
<span class="ansi32">+</span><span class="ansi32">        plt.close()</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    return edge,node</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def customedSort(nodeName):</span>
<span class="ansi32">+</span><span class="ansi32">    return int(re.findall("\d+", nodeName)[0])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">if __name__ == "__main__":</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">    #filename="topo-for-CompareMultiPath.txt"</span>
<span class="ansi32">+</span><span class="ansi32">    filename="18Nodes-2.txt"</span>
<span class="ansi32">+</span><span class="ansi32">    e,n=readTopology("/topologies30/"+filename)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    consumerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    producerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    if(manualAssign):</span>
<span class="ansi32">+</span><span class="ansi32">        consumerList=['Node0','Node1']</span>
<span class="ansi32">+</span><span class="ansi32">        producerList=['Node2','Node3']</span>
<span class="ansi32">+</span><span class="ansi32">        #consumerList=['Node0','Node1','Node2','Node3','Node4','Node5','Node6','Node7','Node8','Node9','Node10','Node11','Node12','Node13']</span>
<span class="ansi32">+</span><span class="ansi32">        #producerList=['Node14','Node15','Node16','Node17','Node18','Node19','Node20','Node21','Node22','Node23','Node24','Node25','Node26','Node27']</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        '''</span>
<span class="ansi32">+</span><span class="ansi32">        d['Node4','Node0']=1</span>
<span class="ansi32">+</span><span class="ansi32">        d['Node3','Node0']=1</span>
<span class="ansi32">+</span><span class="ansi32">        '''</span>
<span class="ansi32">+</span><span class="ansi32">    else:</span>
<span class="ansi32">+</span><span class="ansi32">        K=int(np.floor(len(n)/2))</span>
<span class="ansi32">+</span><span class="ansi32">        nodesName=n.keys()</span>
<span class="ansi32">+</span><span class="ansi32">        nodesName.sort(key=customedSort)</span>
<span class="ansi32">+</span><span class="ansi32">        for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">            consumerList.append(nodesName[k])</span>
<span class="ansi32">+</span><span class="ansi32">            producerList.append(nodesName[k+K])</span>
<span class="ansi32">+</span><span class="ansi32">    d=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    # 数据预处理，缩放</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(consumerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        d[consumerList[i],producerList[i]]=1</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    开始计算，输入有 nodes, edges, dem</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    #构造图G，边的属性只设置 u(e)和 le</span>
<span class="ansi32">+</span><span class="ansi32">    G=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    G.add_nodes_from(n)</span>
<span class="ansi32">+</span><span class="ansi32">    #G.add_edges_from(e,weight=2)</span>
<span class="ansi32">+</span><span class="ansi32">    mp.dbs=50   #浮点数的精度（小数点位数）</span>
<span class="ansi32">+</span><span class="ansi32">    epsilon=0.002</span>
<span class="ansi32">+</span><span class="ansi32">    delta=(mpf(len(e))/(mpf(1)-mpf(epsilon)))**(mpf(-1)/mpf(epsilon))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_edge(i,j,ue=e[i,j]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_edge(i,j,le=delta/mpf(e[i,j]['cap']))</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    startTime=time.time()</span>
<span class="ansi32">+</span><span class="ansi32">    #根据我的论文进行的缩放</span>
<span class="ansi32">+</span><span class="ansi32">    mincap=float(e.values()[0]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(e.values())-1):</span>
<span class="ansi32">+</span><span class="ansi32">        if float(e.values()[i]['cap'])&lt;mincap:</span>
<span class="ansi32">+</span><span class="ansi32">            mincap=float(e.values()[i]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">    rho=mincap/max(d.values())</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        d[i,j]=d[i,j]*rho</span>
<span class="ansi32">+</span><span class="ansi32">    edgeFlows={}</span>
<span class="ansi32">+</span><span class="ansi32">    # 开始计算</span>
<span class="ansi32">+</span><span class="ansi32">    Dl=mpf(0.0)</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        Dl=Dl+G.edges[i,j]['le']</span>
<span class="ansi32">+</span><span class="ansi32">        edgeFlows[i,j]=0.0</span>
<span class="ansi32">+</span><span class="ansi32">    t=0</span>
<span class="ansi32">+</span><span class="ansi32">    while(Dl&lt;1):</span>
<span class="ansi32">+</span><span class="ansi32">        t=t+1</span>
<span class="ansi32">+</span><span class="ansi32">        for (source,target) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            dj=d[source,target]</span>
<span class="ansi32">+</span><span class="ansi32">            while (Dl&lt;1 and dj&gt;0):</span>
<span class="ansi32">+</span><span class="ansi32">                p=nx.shortest_path(G, source, target, 'le')</span>
<span class="ansi32">+</span><span class="ansi32">                minu=int(G[p[0]][p[1]]['ue'])</span>
<span class="ansi32">+</span><span class="ansi32">                # 在链路均匀的情况下，下面的循环是可以省略的,包括后面的le计算中直接使用了minu</span>
<span class="ansi32">+</span><span class="ansi32">                #for q in range(len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                #    minu=min(G[p[q]][p[q+1]]['ue'],minu)</span>
<span class="ansi32">+</span><span class="ansi41">                </span>
<span class="ansi32">+</span><span class="ansi32">                u=min(dj,minu)</span>
<span class="ansi32">+</span><span class="ansi32">                dj=dj-u</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">                for q in range(len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                    edgeFlows[p[q],p[q+1]]=edgeFlows[p[q],p[q+1]]+u</span>
<span class="ansi32">+</span><span class="ansi32">                    G[p[q]][p[q+1]]['le']=G[p[q]][p[q+1]]['le']*(mpf(1)+mpf(epsilon)*mpf(u)/mpf(minu))</span>
<span class="ansi32">+</span><span class="ansi32">                    #print 'G.edges[{0},{1}][le]={2}'.format(p[q],p[q+1],G[p[q]][p[q+1]]['le'])</span>
<span class="ansi32">+</span><span class="ansi32">                for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">                    Dl=Dl+G.edges[i,j]['le']</span>
<span class="ansi32">+</span><span class="ansi32">        if t%10000==0:</span>
<span class="ansi32">+</span><span class="ansi32">            print ('Now t={0}, Dl={1}'.format(t,Dl))</span>
<span class="ansi32">+</span><span class="ansi32">            if t&gt;10000000:</span>
<span class="ansi32">+</span><span class="ansi32">                print ('Timeout without a solution')</span>
<span class="ansi32">+</span><span class="ansi32">                break</span><span class="ansi41">            </span>
<span class="ansi32">+</span><span class="ansi32">    lamb=rho*(t-1)/mp.log(mpf(1)/delta,(1+epsilon))</span>
<span class="ansi32">+</span><span class="ansi32">    #lamb=rho*(t)/mp.log(mpf(1+epsilon)/delta,(1+epsilon))</span>
<span class="ansi32">+</span><span class="ansi32">    print ('lambda is : {0}'.format(lamb))</span>
<span class="ansi32">+</span><span class="ansi32">    print ('耗时：{0} s'.format(time.time()-startTime))</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    scale=mp.log((mpf(1)+mpf(epsilon))/mpf(delta))/mp.log(mpf(1)+mpf(epsilon))</span>
<span class="ansi32">+</span><span class="ansi32">    #print edgeFlows</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi41">    </span>
\ No newline at end of file
<span class="ansi1">diff --git a/examples/mintreeMFP.py b/examples/mintreeMFP.py</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..6676513</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/mintreeMFP.py</span>
<span class="ansi36">@@ -0,0 +1,751 @@</span>
<span class="ansi32">+</span><span class="ansi32"># _*_ coding: utf-8 _*_</span>
<span class="ansi32">+</span><span class="ansi32">from pyscipopt import Model, Conshdlr, quicksum , SCIP_RESULT, SCIP_PRESOLTIMING, SCIP_PROPTIMING, SCIP_PARAMSETTING, SCIP_PARAMEMPHASIS</span>
<span class="ansi32">+</span><span class="ansi32">from pyscipopt.scip import Expr, ExprCons, Term</span>
<span class="ansi32">+</span><span class="ansi32">import networkx as nx             #导入networkx包</span>
<span class="ansi32">+</span><span class="ansi32">from networkx.algorithms.flow import shortest_augmenting_path</span>
<span class="ansi32">+</span><span class="ansi32">import re</span>
<span class="ansi32">+</span><span class="ansi32">import numpy as np</span>
<span class="ansi32">+</span><span class="ansi32">import sys</span>
<span class="ansi32">+</span><span class="ansi32">from collections import OrderedDict</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span><span class="ansi32">2018-3-20</span>
<span class="ansi32">+</span><span class="ansi32">因为ndnSIM中实现的多条路径没有实现流浪的split，只简单复制和Flooding一样的转发，而现在编写的SCIP采用的是randomized</span>
<span class="ansi32">+</span><span class="ansi32">Rounding将traffic split到多条路径中，所以比较是不公平的。为了公平比较，都采用多条路径传输不一样的内容。</span>
<span class="ansi32">+</span><span class="ansi32">目前认为简单的做法是在Python中重写多路径</span>
<span class="ansi32">+</span><span class="ansi32">2017-7-26</span>
<span class="ansi32">+</span><span class="ansi32">reference to mfc from PySCIPOpt/examples/finished/atsp.py</span>
<span class="ansi32">+</span><span class="ansi32">The most complex problem based on node flow conservation is Maximum Concurrent Multicommodity Flow Problem (MCFP). I extended the model of MCFP for solving Steiner Tree</span>
<span class="ansi32">+</span><span class="ansi32">the detail see my latex document.</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">the if there are only the "C" type Vars, Conshdlr consenfolp don't be called</span>
<span class="ansi32">+</span><span class="ansi32">"""</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">EPS = 1.e-6</span>
<span class="ansi32">+</span><span class="ansi32">manualAssign=False</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def mintreeMFP(n,e,d):</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    mintreeMFP: min Cost Tree based on Flow Conservation</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    Parameters:</span>
<span class="ansi32">+</span><span class="ansi32">        - n: number of nodes</span>
<span class="ansi32">+</span><span class="ansi32">        - e[i,j]['cap','cost']: edges of graph, 'cap': capacity of edge, 'cost': cost for traversing edge (i,j)</span>
<span class="ansi32">+</span><span class="ansi32">        - d[i,j]: demande(data) from node i to j</span>
<span class="ansi32">+</span><span class="ansi32">    Returns a model, ready to be solved.</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    print("\n========min Cost Tree based on Flow Conservation======")</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    model=Model("mintreeMFP")</span>
<span class="ansi32">+</span><span class="ansi32">    x,f,z={},{},{}   # flow variable</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    In our model, f[i,j] is the sum of flow on edge, if f[i,j]&gt;0 then z[i,j]=1 else z[i,j]=0, such that get minTree</span>
<span class="ansi32">+</span><span class="ansi32">    In order to express the logical constraint, define a Big M, and z is Binary,</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    z[i,j]&gt;=f[i,j]/M (gurantee f/M &lt;1) and z[i,j]&lt;=f[i,j]*M (gurantee f[i,j]*M &gt;1)</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    M=100000000</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        f[i,j]=model.addVar(ub=1000000,lb=0,vtype="C",name="f[%s,%s]"%(i,j))</span>
<span class="ansi32">+</span><span class="ansi32">        z[i,j]=model.addVar(ub=1,lb=0,vtype="B",name="z[%s,%s]"%(i,j))</span>
<span class="ansi32">+</span><span class="ansi32">        for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            x[i,j,s,t]=model.addVar(ub=1000000,lb=0,vtype="C",name="x[%s,%s,%s,%s]"%(i,j,s,t))</span>
<span class="ansi32">+</span><span class="ansi32">    # node flow conservation</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        for j in n.keys() :</span>
<span class="ansi32">+</span><span class="ansi32">            # for destination node</span>
<span class="ansi32">+</span><span class="ansi32">            if j==t:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == d[s,t], "DesNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            # for source node</span>
<span class="ansi32">+</span><span class="ansi32">            elif j==s:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == -d[s,t], "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == 0, "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">    # constrains for edge capacity, take into consideration of tree optimization, using variable f</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        f[i,j]=quicksum(x[i,j,s,t] for (s,t) in d.keys())</span>
<span class="ansi32">+</span><span class="ansi32">        model.addCons(f[i,j]&lt;=e[i,j]['cap'],'edge(%s,%s)'%(i,j))</span>
<span class="ansi32">+</span><span class="ansi32">        # logical constraint</span>
<span class="ansi32">+</span><span class="ansi32">        model.addCons(M*z[i,j]&gt;=f[i,j])</span>
<span class="ansi32">+</span><span class="ansi32">        model.addCons(z[i,j]&lt;=f[i,j]*M)</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    model.data = x,f</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    #model.setObjective(quicksum(f[i,j]*e[i,j]['cost'] for (i,j) in e.keys()), "minimize")</span>
<span class="ansi32">+</span><span class="ansi32">    model.setObjective(quicksum(z[i,j] for (i,j) in e.keys()), "minimize")</span>
<span class="ansi32">+</span><span class="ansi32">    return model</span>
<span class="ansi32">+</span><span class="ansi41">            </span>
<span class="ansi32">+</span><span class="ansi32">def maxConcurrentMFP(n,e,d):</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    maxConcurrentMFP: max concurrent multi-commodity flow Problem</span>
<span class="ansi32">+</span><span class="ansi32">    Parameters:</span>
<span class="ansi32">+</span><span class="ansi32">        - n: number of nodes</span>
<span class="ansi32">+</span><span class="ansi32">        - e[i,j]['cap','cost']: edges of graph, 'cap': capacity of edge, 'cost': cost for traversing edge (i,j)</span>
<span class="ansi32">+</span><span class="ansi32">        - d[i,j]: demande from node i to j</span>
<span class="ansi32">+</span><span class="ansi32">    Returns a model, ready to be solved.</span>
<span class="ansi32">+</span><span class="ansi32">    后来使用了maxConcurrentFlowMinCostMFP</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    print("\n========concurrent multi-commodity flow Problem======")</span>
<span class="ansi32">+</span><span class="ansi32">    model=Model("maxConcurrentMFP")</span>
<span class="ansi32">+</span><span class="ansi32">    x={}  # flow variable</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    lamb=model.addVar(ub=1000000,lb=1.0,vtype="C",name="lamb")</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            x[i,j,s,t]=model.addVar(ub=1000000,lb=0.0,vtype="I",name="x[%s,%s,%s,%s]"%(i,j,s,t))</span>
<span class="ansi32">+</span><span class="ansi32">    # node flow conservation</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        for j in n.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            # for destination node</span>
<span class="ansi32">+</span><span class="ansi32">            if j==t:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == d[s,t]*lamb, "DesNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            # for source node</span>
<span class="ansi32">+</span><span class="ansi32">            elif j==s:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == -d[s,t]*lamb, "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == 0, "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">    # constrains for edge capacity, take into consideration of tree optimization, using variable f</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        model.addCons(quicksum(x[i,j,s,t] for (s,t) in d.keys())&lt;=e[i,j]['cap'],'edge(%s,%s)'%(i,j))</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    model.data = x</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    model.setObjective(lamb, "maximize")</span>
<span class="ansi32">+</span><span class="ansi32">    return model</span>
<span class="ansi32">+</span><span class="ansi32">def maxConcurrentFlowMinCostMFP(n,e,d):</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    maxConcurrentMFP: max concurrent multi-commodity flow and min Cost Problem</span>
<span class="ansi32">+</span><span class="ansi32">    2018-3-27 如果目标函数中没有加入最小代价，在Mac和Ubuntu下的计算结果都不一样，显然同样的lamb下有多中路由方式。而且也可以去除环路</span>
<span class="ansi32">+</span><span class="ansi32">    Parameters:</span>
<span class="ansi32">+</span><span class="ansi32">        - n: number of nodes</span>
<span class="ansi32">+</span><span class="ansi32">        - e[i,j]['cap','cost']: edges of graph, 'cap': capacity of edge, 'cost': cost for traversing edge (i,j)</span>
<span class="ansi32">+</span><span class="ansi32">        - d[i,j]: demande from node i to j</span>
<span class="ansi32">+</span><span class="ansi32">    Returns a model, ready to be solved.</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    print("\n========concurrent multi-commodity flow Problem======")</span>
<span class="ansi32">+</span><span class="ansi32">    model=Model("maxConcurrentMFP")</span>
<span class="ansi32">+</span><span class="ansi32">    x={}  # flow variable</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    lamb=model.addVar(ub=1000000,lb=1.0,vtype="C",name="lamb")</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            x[i,j,s,t]=model.addVar(ub=1000000,lb=0.0,vtype="I",name="x[%s,%s,%s,%s]"%(i,j,s,t))</span>
<span class="ansi32">+</span><span class="ansi32">    # node flow conservation</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        for j in n.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            # for destination node</span>
<span class="ansi32">+</span><span class="ansi32">            if j==t:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == d[s,t]*lamb, "DesNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            # for source node</span>
<span class="ansi32">+</span><span class="ansi32">            elif j==s:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == -d[s,t]*lamb, "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == 0, "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">    # constrains for edge capacity, take into consideration of tree optimization, using variable f</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        model.addCons(quicksum(x[i,j,s,t] for (s,t) in d.keys())&lt;=e[i,j]['cap'],'edge(%s,%s)'%(i,j))</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    model.data =lamb, x</span>
<span class="ansi32">+</span><span class="ansi32">    model.setObjective(lamb-0.0001*quicksum(quicksum(x[i,j,s,t] for (s,t) in d.keys()) for (i,j) in e.keys()), "maximize")</span>
<span class="ansi32">+</span><span class="ansi32">    #model.setObjective(lamb-(quicksum(0.00000001*quicksum(x[i,j,s,t] for (s,t) in d.keys()) for (i,j) in e.keys())), "maximize")</span>
<span class="ansi32">+</span><span class="ansi32">    return model</span>
<span class="ansi32">+</span><span class="ansi32">def MaxMFP(n,e,d):</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    MaxMFP: Max sum multi-commodity flow Problem</span>
<span class="ansi32">+</span><span class="ansi32">    Parameters:</span>
<span class="ansi32">+</span><span class="ansi32">        - n: number of nodes</span>
<span class="ansi32">+</span><span class="ansi32">        - e[i,j]['cap','cost']: edges of graph, 'cap': capacity of edge, 'cost': cost for traversing edge (i,j)</span>
<span class="ansi32">+</span><span class="ansi32">        - d[i,j]: demande from node i to j</span>
<span class="ansi32">+</span><span class="ansi32">    Returns a model, ready to be solved.</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    print("\n========Max multi-commodity flow Problem======")</span>
<span class="ansi32">+</span><span class="ansi32">    model=Model("MaxMFP")</span>
<span class="ansi32">+</span><span class="ansi32">    x,vard={},{}  # flow variable</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        vard[s,t]=model.addVar(ub=1000000,lb=0.0,vtype="C",name="vard[%s,%s]"%(s,t))</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            x[i,j,s,t]=model.addVar(ub=1000000,lb=0.0,vtype="C",name="x[%s,%s,%s,%s]"%(i,j,s,t))</span>
<span class="ansi32">+</span><span class="ansi32">    # node flow conservation</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        for j in n.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            # for destination node</span>
<span class="ansi32">+</span><span class="ansi32">            if j==t:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == vard[s,t], "DesNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            # for source node</span>
<span class="ansi32">+</span><span class="ansi32">            elif j==s:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == -vard[s,t], "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                model.addCons(quicksum(x[i,j,s,t] for i in n.keys() if (i,j) in e.keys()) -</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">                              quicksum(x[j,i,s,t] for i in n.keys() if (j,i) in e.keys()) == 0, "SourceNode(%s)"%j)</span>
<span class="ansi32">+</span><span class="ansi32">    # constrains for edge capacity, take into consideration of tree optimization, using variable f</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        model.addCons(quicksum(x[i,j,s,t] for (s,t) in d.keys())&lt;=e[i,j]['cap'],'edge(%s,%s)'%(i,j))</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    model.data = x,vard</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    model.setObjective(quicksum(vard[s,t] for (s,t) in d.keys()), "maximize")</span>
<span class="ansi32">+</span><span class="ansi32">    return model</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def readTopology(filename,cap=None):</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    # ZhangYu 2018-1-28使用SCIP计算时，发现这里没有设置是否无向图， 而Matlab有这个选项</span>
<span class="ansi32">+</span><span class="ansi32">    isUndirectedGraph=True</span><span class="ansi41">   </span>
<span class="ansi32">+</span><span class="ansi32">    mark=["router\n","link\n"]</span>
<span class="ansi32">+</span><span class="ansi32">    try:</span>
<span class="ansi32">+</span><span class="ansi32">        filehandle = open(sys.path[0]+filename,'r')</span>
<span class="ansi32">+</span><span class="ansi32">    except:</span>
<span class="ansi32">+</span><span class="ansi32">        print("Could not open file " + sys.path[0]+filename)</span>
<span class="ansi32">+</span><span class="ansi32">        quit()</span>
<span class="ansi32">+</span><span class="ansi32">    filelines=filehandle.readlines()</span>
<span class="ansi32">+</span><span class="ansi32">    markPos=[]</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(mark)):</span>
<span class="ansi32">+</span><span class="ansi32">        markPos.append(filelines.index(mark[i]))</span>
<span class="ansi32">+</span><span class="ansi32">    # read edges</span>
<span class="ansi32">+</span><span class="ansi32">    edge,node={},{}</span>
<span class="ansi32">+</span><span class="ansi32">    for aline in filelines[markPos[1]+1:]:</span>
<span class="ansi32">+</span><span class="ansi32">        if str(aline).startswith('#') | str(aline).startswith(' ') | str(aline).startswith('\n'):</span>
<span class="ansi32">+</span><span class="ansi32">            continue</span>
<span class="ansi32">+</span><span class="ansi32">        else:</span>
<span class="ansi32">+</span><span class="ansi32">            alineArray=str(aline).split()</span>
<span class="ansi32">+</span><span class="ansi32">            if cap is None:</span>
<span class="ansi32">+</span><span class="ansi32">                # 这里允许节点是诸如 UCLA-A这样的名字</span>
<span class="ansi32">+</span><span class="ansi32">                edge[str(alineArray[0]),</span>
<span class="ansi32">+</span><span class="ansi32">                     str(alineArray[1])]={'cap':re.findall(</span>
<span class="ansi32">+</span><span class="ansi32">                         "\d+",str(alineArray[2]))[0],'cost':re.findall("\d+",str(alineArray[3]))[0]}</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                edge[str(alineArray[0]),</span>
<span class="ansi32">+</span><span class="ansi32">                     str(alineArray[1])]={'cap':cap,'cost':re.findall("\d+",str(alineArray[3]))[0]}</span>
<span class="ansi32">+</span><span class="ansi32">            if isUndirectedGraph:</span>
<span class="ansi32">+</span><span class="ansi32">                edge[str(alineArray[1]),str(alineArray[0])]=edge[str(alineArray[0]),str(alineArray[1])]</span>
<span class="ansi32">+</span><span class="ansi41">                </span>
<span class="ansi32">+</span><span class="ansi32">    # read nodes. G can be get only by edges, we read nodes here because we need the nodes coordinate for drawing graph</span>
<span class="ansi32">+</span><span class="ansi32">    for aline in filelines[markPos[0]+1:markPos[1]]:</span>
<span class="ansi32">+</span><span class="ansi32">        if str(aline).startswith('#') | str(aline).startswith(' ') | str(aline).startswith('\n') | str(aline).startswith('\r'):</span>
<span class="ansi32">+</span><span class="ansi32">            continue</span>
<span class="ansi32">+</span><span class="ansi32">        else:</span>
<span class="ansi32">+</span><span class="ansi32">            alineArray=str(aline).split()</span>
<span class="ansi32">+</span><span class="ansi32">            node[str(alineArray[0])]=np.array(</span>
<span class="ansi32">+</span><span class="ansi32">                [int(re.findall("\d+", str(alineArray[3]))[0]),int(re.findall("\d+", str(alineArray[2]))[0])])</span>
<span class="ansi32">+</span><span class="ansi32">            #pos['1']=np.array([4,5])</span>
<span class="ansi32">+</span><span class="ansi41">            </span>
<span class="ansi32">+</span><span class="ansi32">    if __name__=="__main__":</span>
<span class="ansi32">+</span><span class="ansi32">        import matplotlib.pyplot as plt</span>
<span class="ansi32">+</span><span class="ansi32">        G=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_nodes_from(node)</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_edges_from(edge.keys())</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        # Draw nodes</span>
<span class="ansi32">+</span><span class="ansi32">        nx.draw_networkx_nodes(G, node,node_size=290, node_color='orange')</span>
<span class="ansi32">+</span><span class="ansi32">        nx.draw_networkx_labels(G, node,font_size=13, font_family='sans-serif')</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        # Draw edges</span>
<span class="ansi32">+</span><span class="ansi32">        nx.draw_networkx_edges(G,node, arrows=True,width=0.5, edge_color='g')</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        # Draw edge labels</span>
<span class="ansi32">+</span><span class="ansi32">        #edge_labels = dict([((u, v), d['label'])</span>
<span class="ansi32">+</span><span class="ansi32">        #                    for u, v, d in G.edges(data=True)])</span>
<span class="ansi32">+</span><span class="ansi32">        #nx.draw_networkx_edge_labels(G, pos,edge_labels=edge_labels)</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        plt.axis('off')  # 是否打开坐标系on/off</span>
<span class="ansi32">+</span><span class="ansi32">        #plt.savefig("lyy_graph.eps", format='eps')  # save as eps</span>
<span class="ansi32">+</span><span class="ansi32">        #plt.ion()</span>
<span class="ansi32">+</span><span class="ansi32">        plt.pause(5)</span>
<span class="ansi32">+</span><span class="ansi32">        #plt.close()</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    return edge,node</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def caculatemaxConcurrentMFPRoute(filename,consumerList,producerList):</span>
<span class="ansi32">+</span><span class="ansi32">    # Traffic Matrix d[1,5] represent interest from node 1 to node 5</span>
<span class="ansi32">+</span><span class="ansi32">    e,n=readTopology(filename)</span>
<span class="ansi32">+</span><span class="ansi32">    d=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(consumerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        d[consumerList[i],producerList[i]]=1</span>
<span class="ansi32">+</span><span class="ansi32">    #model=maxConcurrentMFP(n, e, d)</span>
<span class="ansi32">+</span><span class="ansi32">    model=maxConcurrentFlowMinCostMFP(n,e,d)</span>
<span class="ansi32">+</span><span class="ansi32">    model.hideOutput()</span>
<span class="ansi32">+</span><span class="ansi32">    model.optimize()</span>
<span class="ansi32">+</span><span class="ansi32">    vlamb,x = model.data</span>
<span class="ansi32">+</span><span class="ansi32">    lamb=model.getVal(vlamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------variant lambda is:",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------obj is: ",model.getObjVal())</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    for v in model.getVars():</span>
<span class="ansi32">+</span><span class="ansi32">        if model.getVal(v)&gt;EPS:</span>
<span class="ansi32">+</span><span class="ansi32">            print('{0}={1}'.format(v.name,model.getVal(v)))</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        if(d[s,t]&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">            for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">                if(model.getVal(x[i,j,s,t])&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">                    print('--------x[{0},{1},{2},{3}]={4}'.format(i,j,s,t,model.getVal(x[i,j,s,t])))</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">    routeList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    probability=1.0</span>
<span class="ansi32">+</span><span class="ansi32">    rG=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        # 2018-3-26，为了去掉解中的路由环路</span>
<span class="ansi32">+</span><span class="ansi32">        rG.clear()</span>
<span class="ansi32">+</span><span class="ansi32">        for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            if(model.getVal(x[i,j,s,t])&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">                rG.add_edge(i,j,capacity=model.getVal(x[i,j,s,t]))</span>
<span class="ansi32">+</span><span class="ansi32">        R = shortest_augmenting_path(rG, s, t)</span>
<span class="ansi32">+</span><span class="ansi32">        if R.graph['flow_value']+EPS&lt;lamb:</span>
<span class="ansi32">+</span><span class="ansi32">            print ("2018-3-26 全局解的最大流没有达到lambda")</span>
<span class="ansi32">+</span><span class="ansi32">            print ("最大流：{0}".format(R.graph['flow_value']))</span>
<span class="ansi32">+</span><span class="ansi32">            continue</span>
<span class="ansi32">+</span><span class="ansi32">        ''' ******traffic split 实现方法*********</span>
<span class="ansi32">+</span><span class="ansi32">        因为即使没有环路，也不能保证一种商品流的多条路径没有公共节点，当有公共节点时，例如节点 Node5流入有两条边共200</span>
<span class="ansi32">+</span><span class="ansi32">        流出有2条（边的容量是100）。在转发时，默认的转发策略ncc和Flooding一样，向所有端口复制，导致每条边都有200，</span>
<span class="ansi32">+</span><span class="ansi32">        由于超出带宽，会被迫丢包，但是丢包不能保证公平，所以仿真结果和预期差别较大</span>
<span class="ansi32">+</span><span class="ansi32">        为避免上述情况，这里是针对源节点，分流概率为 流量/lamb，对于中继节点，概率=流量/流入该节点的总和</span>
<span class="ansi32">+</span><span class="ansi32">        当使用概率转发时，可以split流量，和cpp中的多路径不一样</span>
<span class="ansi32">+</span><span class="ansi32">        '''</span>
<span class="ansi32">+</span><span class="ansi32">        # 计算节点的流入流量总和</span>
<span class="ansi32">+</span><span class="ansi32">        inFlow={}</span>
<span class="ansi32">+</span><span class="ansi32">        for aNode in R.nodes:</span>
<span class="ansi32">+</span><span class="ansi32">            inFlow[aNode]=0</span>
<span class="ansi32">+</span><span class="ansi32">            for (eStart,aNode) in rG.in_edges(aNode):</span>
<span class="ansi32">+</span><span class="ansi32">                inFlow[aNode]=inFlow[aNode]+R[eStart][aNode]['flow']</span>
<span class="ansi32">+</span><span class="ansi32">        for (i,j) in rG.edges :</span>
<span class="ansi32">+</span><span class="ansi32">            if(R[i][j]['flow']&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">                if (i==s):</span>
<span class="ansi32">+</span><span class="ansi32">                    totalInFlow=lamb</span>
<span class="ansi32">+</span><span class="ansi32">                else:</span>
<span class="ansi32">+</span><span class="ansi32">                    totalInFlow=inFlow[i]</span>
<span class="ansi32">+</span><span class="ansi32">                    if (totalInFlow==0):</span>
<span class="ansi32">+</span><span class="ansi32">                        print ("i={0},j={1},s={2},t={3},flow={4},inFlow={5}".format(i,j,s,t,R[i][j]['flow'],inFlow[i]))</span>
<span class="ansi32">+</span><span class="ansi32">                r={'edgeStart':i,'edgeEnd':j,'prefix':"/"+t,'cost':1, 'probability':</span>
<span class="ansi32">+</span><span class="ansi32">                   (R[i][j]['flow']/totalInFlow)}</span>
<span class="ansi32">+</span><span class="ansi32">                routeList.append(r)</span>
<span class="ansi32">+</span><span class="ansi32">                print (r)</span>
<span class="ansi32">+</span><span class="ansi32">    return lamb,routeList</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def caculatenoCommLinkPairFirst(filename,consumerList,producerList):</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    GNOMP: caculate no comm link pair first multipath routing</span>
<span class="ansi32">+</span><span class="ansi32">    Parameters:</span>
<span class="ansi32">+</span><span class="ansi32">        - filename: topology file name</span>
<span class="ansi32">+</span><span class="ansi32">        - consumerList: consumer list, need the ascend order</span>
<span class="ansi32">+</span><span class="ansi32">        - producerList:</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    Returns maxThroughput, lambda, routeList</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    if __name__=="__main__":</span>
<span class="ansi32">+</span><span class="ansi32">       print("\n========caculate no common link multipath pair first======")</span>
<span class="ansi32">+</span><span class="ansi32">    e,n=readTopology(filename)</span>
<span class="ansi32">+</span><span class="ansi32">    edgecapacity=0;</span>
<span class="ansi32">+</span><span class="ansi32">    d=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(consumerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        d[consumerList[i],producerList[i]]=1</span>
<span class="ansi32">+</span><span class="ansi32">    G=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    G.add_nodes_from(n)</span>
<span class="ansi32">+</span><span class="ansi32">    #G.add_edges_from(e,weight=2)</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_edge(i,j,weight=e[i,j]['cost'])</span>
<span class="ansi32">+</span><span class="ansi32">        edgecapacity=int(e[i,j]['cap']) #这里认为网络容量是均匀的，所以用了偷懒的做法</span>
<span class="ansi32">+</span><span class="ansi32">        #print(G[i][j]['weight'])</span>
<span class="ansi32">+</span><span class="ansi32">        #print(G.edges[i,j]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">    pathsList=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    hasPath=True</span>
<span class="ansi32">+</span><span class="ansi32">    while(hasPath):</span>
<span class="ansi32">+</span><span class="ansi32">        hasPath=False</span>
<span class="ansi32">+</span><span class="ansi32">        for (s,t) in d:</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">            # 很奇怪，下面写'weight'竟然不识别报错</span>
<span class="ansi32">+</span><span class="ansi32">            try:</span>
<span class="ansi32">+</span><span class="ansi32">                p=nx.shortest_path(G, s, t, 'cost')</span>
<span class="ansi32">+</span><span class="ansi32">            except:</span>
<span class="ansi32">+</span><span class="ansi32">                continue</span>
<span class="ansi32">+</span><span class="ansi32">            if(len(p)&gt;1):</span>
<span class="ansi32">+</span><span class="ansi32">                hasPath=True</span>
<span class="ansi32">+</span><span class="ansi32">                if(not(pathsList.has_key((s,t)))):</span>
<span class="ansi32">+</span><span class="ansi32">                    pathsList[s,t]=[]</span>
<span class="ansi32">+</span><span class="ansi32">                pathsList[s,t].append(p)</span>
<span class="ansi32">+</span><span class="ansi32">                print ('  ----source:{0}, sink:{1}, path:{2}'.format(s,t,p))</span>
<span class="ansi32">+</span><span class="ansi32">                for i in range(0,len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                    G.remove_edge(p[i], p[i+1])</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                continue</span>
<span class="ansi32">+</span><span class="ansi32">    routeList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    MaxThroughput=0</span>
<span class="ansi32">+</span><span class="ansi32">    lamb=np.inf</span>
<span class="ansi32">+</span><span class="ansi32">    rG=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in pathsList.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        #print("source:{0}  sink:{1}   total paths:{2}  ".format(s,t,len(pathsList[s,t])))</span>
<span class="ansi32">+</span><span class="ansi32">        MaxThroughput=MaxThroughput+(edgecapacity*len(pathsList[s,t]))</span>
<span class="ansi32">+</span><span class="ansi32">        if (edgecapacity*len(pathsList[s,t])&lt;lamb):</span>
<span class="ansi32">+</span><span class="ansi32">            lamb=edgecapacity*len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">        #得到每对节点对的流量图</span>
<span class="ansi32">+</span><span class="ansi32">        rG.clear()</span>
<span class="ansi32">+</span><span class="ansi32">        #probability=1.0/len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">        for i in range(len(pathsList[s,t])):</span>
<span class="ansi32">+</span><span class="ansi32">            p=pathsList[s,t][i]</span>
<span class="ansi32">+</span><span class="ansi32">            for j in range(len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                rG.add_edge(p[j], p[j+1],capacity=e[p[j],p[j+1]]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">        #计算节点的流量总和</span>
<span class="ansi32">+</span><span class="ansi32">        inFlow={}</span>
<span class="ansi32">+</span><span class="ansi32">        for aNode in rG.nodes:</span>
<span class="ansi32">+</span><span class="ansi32">            inFlow[aNode]=0</span>
<span class="ansi32">+</span><span class="ansi32">            for (eStart,aNode) in rG.in_edges(aNode):</span>
<span class="ansi32">+</span><span class="ansi32">                inFlow[aNode]=inFlow[aNode]+float(rG[eStart][aNode]['capacity'])</span>
<span class="ansi32">+</span><span class="ansi32">        #生成路由表</span>
<span class="ansi32">+</span><span class="ansi32">        for (i,j) in rG.edges :</span>
<span class="ansi32">+</span><span class="ansi32">            if (i==s):</span>
<span class="ansi32">+</span><span class="ansi32">                totalInFlow=edgecapacity*len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                totalInFlow=inFlow[i]</span>
<span class="ansi32">+</span><span class="ansi32">            r={'edgeStart':i,'edgeEnd':j,'prefix':"/"+t,'cost':1, 'probability':</span>
<span class="ansi32">+</span><span class="ansi32">               (float(rG[i][j]['capacity'])/totalInFlow)}</span>
<span class="ansi32">+</span><span class="ansi32">            routeList.append(r)</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">                #print r</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    # 如果某对s-t没有路径，上面的求lamb只是找到了存在的路径中的最小lamb，对s-t流量为0的没处理，因此补上下面的语句</span>
<span class="ansi32">+</span><span class="ansi32">    if(len(pathsList.keys())&lt;len(d)):</span>
<span class="ansi32">+</span><span class="ansi32">        lamb=0</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    return MaxThroughput,lamb,routeList</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def caculateKshortest(filename,consumerList,producerList,K):</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    K-shortest: caculate K-shortest multipath routing, find all K-shortest path for a pair then another pair</span>
<span class="ansi32">+</span><span class="ansi32">    Parameters:</span>
<span class="ansi32">+</span><span class="ansi32">        - filename: topology file name</span>
<span class="ansi32">+</span><span class="ansi32">        - consumerList: consumer list, need the ascend order</span>
<span class="ansi32">+</span><span class="ansi32">        - producerList:</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">        - K: K=1 is BestRoute, K=np.inf is Flooding</span>
<span class="ansi32">+</span><span class="ansi32">    Returns maxThroughput, lambda, routeList</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    if __name__=="__main__":</span>
<span class="ansi32">+</span><span class="ansi32">       print("\n========caculate K-shortest Path======")</span>
<span class="ansi32">+</span><span class="ansi32">    e,n=readTopology(filename)</span>
<span class="ansi32">+</span><span class="ansi32">    edgecapacity=0;</span>
<span class="ansi32">+</span><span class="ansi32">    d=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(consumerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        d[consumerList[i],producerList[i]]=1</span>
<span class="ansi32">+</span><span class="ansi32">    G=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    G.add_nodes_from(n)</span>
<span class="ansi32">+</span><span class="ansi32">    #G.add_edges_from(e,weight=2)</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_edge(i,j,weight=e[i,j]['cost'])</span>
<span class="ansi32">+</span><span class="ansi32">        edgecapacity=int(e[i,j]['cap']) #这里认为网络容量是均匀的，所以用了偷懒的做法</span>
<span class="ansi32">+</span><span class="ansi32">        #print(G[i][j]['weight'])</span>
<span class="ansi32">+</span><span class="ansi32">        #print(G.edges[i,j]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">    pathsList=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d:</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">        for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">            # 很奇怪，下面写'weight'竟然不识别报错</span>
<span class="ansi32">+</span><span class="ansi32">            try:</span>
<span class="ansi32">+</span><span class="ansi32">                p=nx.shortest_path(G, s, t, 'cost')</span>
<span class="ansi32">+</span><span class="ansi32">            except:</span>
<span class="ansi32">+</span><span class="ansi32">                break</span>
<span class="ansi32">+</span><span class="ansi32">            if(len(p)&gt;1):</span>
<span class="ansi32">+</span><span class="ansi32">                if(not(pathsList.has_key((s,t)))):</span>
<span class="ansi32">+</span><span class="ansi32">                    pathsList[s,t]=[]</span>
<span class="ansi32">+</span><span class="ansi32">                pathsList[s,t].append(p)</span>
<span class="ansi32">+</span><span class="ansi32">                print ('  ----source:{0}, sink:{1}, path:{2}'.format(s,t,p))</span>
<span class="ansi32">+</span><span class="ansi32">                for i in range(0,len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                    G.remove_edge(p[i], p[i+1])</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                break</span>
<span class="ansi32">+</span><span class="ansi32">    routeList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    MaxThroughput=0</span>
<span class="ansi32">+</span><span class="ansi32">    lamb=np.inf</span>
<span class="ansi32">+</span><span class="ansi32">    rG=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in pathsList.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        #print("source:{0}  sink:{1}   total paths:{2}  ".format(s,t,len(pathsList[s,t])))</span>
<span class="ansi32">+</span><span class="ansi32">        MaxThroughput=MaxThroughput+(edgecapacity*len(pathsList[s,t]))</span>
<span class="ansi32">+</span><span class="ansi32">        if (edgecapacity*len(pathsList[s,t])&lt;lamb):</span>
<span class="ansi32">+</span><span class="ansi32">            lamb=edgecapacity*len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">        #得到每对节点对的流量图</span>
<span class="ansi32">+</span><span class="ansi32">        rG.clear()</span>
<span class="ansi32">+</span><span class="ansi32">        #probability=1.0/len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">        for i in range(len(pathsList[s,t])):</span>
<span class="ansi32">+</span><span class="ansi32">            p=pathsList[s,t][i]</span>
<span class="ansi32">+</span><span class="ansi32">            for j in range(len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                rG.add_edge(p[j], p[j+1],capacity=e[p[j],p[j+1]]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">        #计算节点的流量总和</span>
<span class="ansi32">+</span><span class="ansi32">        inFlow={}</span>
<span class="ansi32">+</span><span class="ansi32">        for aNode in rG.nodes:</span>
<span class="ansi32">+</span><span class="ansi32">            inFlow[aNode]=0</span>
<span class="ansi32">+</span><span class="ansi32">            for (eStart,aNode) in rG.in_edges(aNode):</span>
<span class="ansi32">+</span><span class="ansi32">                inFlow[aNode]=inFlow[aNode]+float(rG[eStart][aNode]['capacity'])</span>
<span class="ansi32">+</span><span class="ansi32">        #生成路由表</span>
<span class="ansi32">+</span><span class="ansi32">        for (i,j) in rG.edges :</span>
<span class="ansi32">+</span><span class="ansi32">            if (i==s):</span>
<span class="ansi32">+</span><span class="ansi32">                totalInFlow=edgecapacity*len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                totalInFlow=inFlow[i]</span>
<span class="ansi32">+</span><span class="ansi32">            r={'edgeStart':i,'edgeEnd':j,'prefix':"/"+t,'cost':1, 'probability':</span>
<span class="ansi32">+</span><span class="ansi32">               (float(rG[i][j]['capacity'])/totalInFlow)}</span>
<span class="ansi32">+</span><span class="ansi32">            routeList.append(r)</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">                #print r</span>
<span class="ansi32">+</span><span class="ansi32">    # 如果某对s-t没有路径，上面的求lamb只是找到了存在的路径中的最小lamb，对s-t流量为0的没处理，因此补上下面的语句</span>
<span class="ansi32">+</span><span class="ansi32">    if(len(pathsList.keys())&lt;len(d)):</span>
<span class="ansi32">+</span><span class="ansi32">        lamb=0</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    return MaxThroughput,lamb,routeList</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def caculateKshortestwithRestore(filename,consumerList,producerList,K):</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    restroe original graph after each K-shortest: caculate K-shortest multipath routing,</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">    find all K-shortest path for a pair then restore graph to orighinal for another pair</span>
<span class="ansi32">+</span><span class="ansi32">    Parameters:</span>
<span class="ansi32">+</span><span class="ansi32">        - filename: topology file name</span>
<span class="ansi32">+</span><span class="ansi32">        - consumerList: consumer list, need the ascend order</span>
<span class="ansi32">+</span><span class="ansi32">        - producerList:</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">        - K: K=1 is BestRoute, K=np.inf is Flooding</span>
<span class="ansi32">+</span><span class="ansi32">    Returns maxThroughput, lambda, routeList</span>
<span class="ansi32">+</span><span class="ansi32">    """</span>
<span class="ansi32">+</span><span class="ansi32">    if __name__=="__main__":</span>
<span class="ansi32">+</span><span class="ansi32">       print("\n========caculate K-shortest Path with Restore======")</span>
<span class="ansi32">+</span><span class="ansi32">    e,n=readTopology(filename)</span>
<span class="ansi32">+</span><span class="ansi32">    edgecapacity=0;</span>
<span class="ansi32">+</span><span class="ansi32">    d=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(consumerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        d[consumerList[i],producerList[i]]=1</span>
<span class="ansi32">+</span><span class="ansi32">    G=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    G.add_nodes_from(n)</span>
<span class="ansi32">+</span><span class="ansi32">    #G.add_edges_from(e,weight=2)</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        G.add_edge(i,j,weight=e[i,j]['cost'])</span>
<span class="ansi32">+</span><span class="ansi32">        edgecapacity=int(e[i,j]['cap']) #这里认为网络容量是均匀的，所以用了偷懒的做法</span>
<span class="ansi32">+</span><span class="ansi32">        #print(G[i][j]['weight'])</span>
<span class="ansi32">+</span><span class="ansi32">        #print(G.edges[i,j]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">    if nx.__version__=="2.1" or nx.__version__=="2.2":</span>
<span class="ansi32">+</span><span class="ansi32">        originalG=G.copy(as_view=False)</span>
<span class="ansi32">+</span><span class="ansi32">    else:</span>
<span class="ansi32">+</span><span class="ansi32">        originalG=G.copy(with_data=True)</span>
<span class="ansi32">+</span><span class="ansi32">    pathsList=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d:</span><span class="ansi41"> </span>
<span class="ansi32">+</span><span class="ansi32">        for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">            # 很奇怪，下面写'weight'竟然不识别报错</span>
<span class="ansi32">+</span><span class="ansi32">            try:</span>
<span class="ansi32">+</span><span class="ansi32">                p=nx.shortest_path(G, s, t, 'cost')</span>
<span class="ansi32">+</span><span class="ansi32">            except:</span>
<span class="ansi32">+</span><span class="ansi32">                break</span>
<span class="ansi32">+</span><span class="ansi32">            if(len(p)&gt;1):</span>
<span class="ansi32">+</span><span class="ansi32">                if(not(pathsList.has_key((s,t)))):</span>
<span class="ansi32">+</span><span class="ansi32">                    pathsList[s,t]=[]</span>
<span class="ansi32">+</span><span class="ansi32">                pathsList[s,t].append(p)</span>
<span class="ansi32">+</span><span class="ansi32">                print ('  ----source:{0}, sink:{1}, path:{2}'.format(s,t,p))</span>
<span class="ansi32">+</span><span class="ansi32">                for i in range(0,len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                    G.remove_edge(p[i], p[i+1])</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                break</span>
<span class="ansi32">+</span><span class="ansi32">        if nx.__version__=="2.1" or nx.__version__=="2.2":</span>
<span class="ansi32">+</span><span class="ansi32">            G=originalG.copy(as_view=False)</span>
<span class="ansi32">+</span><span class="ansi32">        else:</span>
<span class="ansi32">+</span><span class="ansi32">            G=originalG.copy(with_data=True)</span>
<span class="ansi32">+</span><span class="ansi32">    routeList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    MaxThroughput=0</span>
<span class="ansi32">+</span><span class="ansi32">    lamb=np.inf</span>
<span class="ansi32">+</span><span class="ansi32">    rG=nx.DiGraph()</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in pathsList.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        #print("source:{0}  sink:{1}   total paths:{2}  ".format(s,t,len(pathsList[s,t])))</span>
<span class="ansi32">+</span><span class="ansi32">        MaxThroughput=MaxThroughput+(edgecapacity*len(pathsList[s,t]))</span>
<span class="ansi32">+</span><span class="ansi32">        if (edgecapacity*len(pathsList[s,t])&lt;lamb):</span>
<span class="ansi32">+</span><span class="ansi32">            lamb=edgecapacity*len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">        #得到每对节点对的流量图</span>
<span class="ansi32">+</span><span class="ansi32">        rG.clear()</span>
<span class="ansi32">+</span><span class="ansi32">        #probability=1.0/len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">        for i in range(len(pathsList[s,t])):</span>
<span class="ansi32">+</span><span class="ansi32">            p=pathsList[s,t][i]</span>
<span class="ansi32">+</span><span class="ansi32">            for j in range(len(p)-1):</span>
<span class="ansi32">+</span><span class="ansi32">                rG.add_edge(p[j], p[j+1],capacity=e[p[j],p[j+1]]['cap'])</span>
<span class="ansi32">+</span><span class="ansi32">        #计算节点的流量总和</span>
<span class="ansi32">+</span><span class="ansi32">        inFlow={}</span>
<span class="ansi32">+</span><span class="ansi32">        for aNode in rG.nodes:</span>
<span class="ansi32">+</span><span class="ansi32">            inFlow[aNode]=0</span>
<span class="ansi32">+</span><span class="ansi32">            for (eStart,aNode) in rG.in_edges(aNode):</span>
<span class="ansi32">+</span><span class="ansi32">                inFlow[aNode]=inFlow[aNode]+float(rG[eStart][aNode]['capacity'])</span>
<span class="ansi32">+</span><span class="ansi32">        #生成路由表</span>
<span class="ansi32">+</span><span class="ansi32">        for (i,j) in rG.edges :</span>
<span class="ansi32">+</span><span class="ansi32">            if (i==s):</span>
<span class="ansi32">+</span><span class="ansi32">                totalInFlow=edgecapacity*len(pathsList[s,t])</span>
<span class="ansi32">+</span><span class="ansi32">            else:</span>
<span class="ansi32">+</span><span class="ansi32">                totalInFlow=inFlow[i]</span>
<span class="ansi32">+</span><span class="ansi32">            r={'edgeStart':i,'edgeEnd':j,'prefix':"/"+t,'cost':1, 'probability':</span>
<span class="ansi32">+</span><span class="ansi32">               (float(rG[i][j]['capacity'])/totalInFlow)}</span>
<span class="ansi32">+</span><span class="ansi32">            routeList.append(r)</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">            #print r</span>
<span class="ansi32">+</span><span class="ansi32">    # 如果某对s-t没有路径，上面的求lamb只是找到了存在的路径中的最小lamb，对s-t流量为0的没处理，因此补上下面的语句</span>
<span class="ansi32">+</span><span class="ansi32">    if(len(pathsList.keys())&lt;len(d)):</span>
<span class="ansi32">+</span><span class="ansi32">        lamb=0</span>
<span class="ansi32">+</span><span class="ansi32">    return MaxThroughput,lamb,routeList</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">def caculateMaxMFPRoute(filename,consumerList,producerList):</span>
<span class="ansi32">+</span><span class="ansi32">    # Traffic Matrix d[1,5] represent interest from node 1 to node 5</span>
<span class="ansi32">+</span><span class="ansi32">    e,n=readTopology(filename)</span>
<span class="ansi32">+</span><span class="ansi32">    d={}</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(consumerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        d[consumerList[i],producerList[i]]=1</span>
<span class="ansi32">+</span><span class="ansi32">    model=maxConcurrentMFP(n, e, d)</span>
<span class="ansi32">+</span><span class="ansi32">    model.hideOutput()</span>
<span class="ansi32">+</span><span class="ansi32">    model.optimize()</span>
<span class="ansi32">+</span><span class="ansi32">    lamb=model.getObjVal()</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------variant lambda is:",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    for v in model.getVars():</span>
<span class="ansi32">+</span><span class="ansi32">        if model.getVal(v)&gt;EPS:</span>
<span class="ansi32">+</span><span class="ansi32">            print('{0}={1}'.format(v.name,model.getVal(v)))</span>
<span class="ansi32">+</span><span class="ansi41">            </span>
<span class="ansi32">+</span><span class="ansi32">    x = model.data</span>
<span class="ansi32">+</span><span class="ansi32">    routeList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">        for (i,j) in e.keys() :</span>
<span class="ansi32">+</span><span class="ansi32">            if(model.getVal(x[i,j,s,t])&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">                d={'edgeStart':i,'prefix':"/"+t,'edgeEnd':j}</span>
<span class="ansi32">+</span><span class="ansi32">                routeList.append(d)</span>
<span class="ansi32">+</span><span class="ansi32">                #print('edgeUsed({0},{1})={2}',format(i,j,z[i,j]))</span>
<span class="ansi32">+</span><span class="ansi32">    return routeList</span>
<span class="ansi32">+</span><span class="ansi32">def TenNodesTopology():</span>
<span class="ansi32">+</span><span class="ansi32">    isUndirectedGraph=True</span>
<span class="ansi32">+</span><span class="ansi32">    n=dict()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(1,10):</span>
<span class="ansi32">+</span><span class="ansi32">        n[i]=1</span>
<span class="ansi32">+</span><span class="ansi32">    e,d={},{}</span>
<span class="ansi32">+</span><span class="ansi32">    e[1,2]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[1,3]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[1,4]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[1,5]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[1,6]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[2,3]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[2,6]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[3,4]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[3,6]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[4,5]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[4,6]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[5,6]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[7,1]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[7,3]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[8,1]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[8,5]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[9,2]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[9,3]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[9,4]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[9,5]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[10,9]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[10,6]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[10,1]={'cap':10,'cost':2}</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    d[1,3]=1</span>
<span class="ansi32">+</span><span class="ansi32">    d[1,5]=1</span>
<span class="ansi32">+</span><span class="ansi32">    d[9,6]=1</span>
<span class="ansi32">+</span><span class="ansi32">    d[7,1]=1</span>
<span class="ansi32">+</span><span class="ansi32">    #d[2,6]=1</span>
<span class="ansi32">+</span><span class="ansi32">    #d[4,6]=1</span>
<span class="ansi32">+</span><span class="ansi32">    if isUndirectedGraph:</span>
<span class="ansi32">+</span><span class="ansi32">        for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            e[j,i]=e[i,j]</span>
<span class="ansi32">+</span><span class="ansi32">    return n,e,d</span>
<span class="ansi32">+</span><span class="ansi32">def SixNodesTopology():</span>
<span class="ansi32">+</span><span class="ansi32">    n=6</span>
<span class="ansi32">+</span><span class="ansi32">    e,d={},{}</span>
<span class="ansi32">+</span><span class="ansi32">    e[0,1]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[0,2]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[0,5]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[5,3]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[1,4]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[2,4]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    e[2,3]={'cap':10,'cost':2}</span>
<span class="ansi32">+</span><span class="ansi32">    # Traffic Matrix d[1,5] represent data from node 1 to node 5</span>
<span class="ansi32">+</span><span class="ansi32">    d['Node0','Node4']=1</span>
<span class="ansi32">+</span><span class="ansi32">    #d['Node0','Node3']=1</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">为了能支持更一般化的节点名字，所以在 readTopology中没有提取节点的数值部分。但是为了和Matlab中节点的顺序一致</span>
<span class="ansi32">+</span><span class="ansi32">以便于能自动产生一样的Traffic，所以这里必须按照数值部分排序，Node11不能自动排在Node2之前，所以需要提取数字</span>
<span class="ansi32">+</span><span class="ansi32">'''</span>
<span class="ansi32">+</span><span class="ansi32">def customedSort(nodeName):</span>
<span class="ansi32">+</span><span class="ansi32">    return int(re.findall("\d+", nodeName)[0])</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">if __name__ == "__main__":</span>
<span class="ansi32">+</span><span class="ansi32">    filename="5nodes-Debug.txt"</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    filename="topo-for-CompareMultiPath.txt"</span>
<span class="ansi32">+</span><span class="ansi32">    #filename="200Nodes-4.txt"</span>
<span class="ansi32">+</span><span class="ansi32">    e,n=readTopology("/topologies/"+filename)</span>
<span class="ansi32">+</span><span class="ansi32">    manualAssign=False</span>
<span class="ansi32">+</span><span class="ansi32">    consumerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    producerList=[]</span>
<span class="ansi32">+</span><span class="ansi32">    if(manualAssign):</span>
<span class="ansi32">+</span><span class="ansi32">        consumerList=['Node0']</span>
<span class="ansi32">+</span><span class="ansi32">        producerList=['Node3']</span>
<span class="ansi32">+</span><span class="ansi32">        #consumerList=['Node0','Node1','Node2','Node3','Node4','Node5','Node6','Node7','Node8','Node9','Node10','Node11','Node12','Node13']</span>
<span class="ansi32">+</span><span class="ansi32">        #producerList=['Node14','Node15','Node16','Node17','Node18','Node19','Node20','Node21','Node22','Node23','Node24','Node25','Node26','Node27']</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">        '''</span>
<span class="ansi32">+</span><span class="ansi32">        d['Node4','Node0']=1</span>
<span class="ansi32">+</span><span class="ansi32">        d['Node3','Node0']=1</span>
<span class="ansi32">+</span><span class="ansi32">        '''</span>
<span class="ansi32">+</span><span class="ansi32">    else:</span>
<span class="ansi32">+</span><span class="ansi32">        K=int(np.floor(len(n)/2))</span>
<span class="ansi32">+</span><span class="ansi32">        nodesName=n.keys()</span>
<span class="ansi32">+</span><span class="ansi32">        nodesName.sort(key=customedSort)</span>
<span class="ansi32">+</span><span class="ansi32">        for k in range(K):</span>
<span class="ansi32">+</span><span class="ansi32">            consumerList.append(nodesName[k])</span>
<span class="ansi32">+</span><span class="ansi32">            producerList.append(nodesName[k+K])</span>
<span class="ansi32">+</span><span class="ansi32">    d=OrderedDict()</span>
<span class="ansi32">+</span><span class="ansi32">    for i in range(len(consumerList)):</span>
<span class="ansi32">+</span><span class="ansi32">        d[consumerList[i],producerList[i]]=1</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    model=mintreeMFP(n,e,d)</span>
<span class="ansi32">+</span><span class="ansi32">    model.hideOutput()</span>
<span class="ansi32">+</span><span class="ansi32">    model.optimize()</span>
<span class="ansi32">+</span><span class="ansi32">    maxFlow = model.getObjVal()</span>
<span class="ansi32">+</span><span class="ansi32">    print "  ------minTreeMFP Optimal value: ",maxFlow</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">    for v in model.getVars():</span>
<span class="ansi32">+</span><span class="ansi32">        if model.getVal(v)&gt;EPS:</span>
<span class="ansi32">+</span><span class="ansi32">            print('{0}={1}'.format(v.name,model.getVal(v)))</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    x,f = model.data</span>
<span class="ansi32">+</span><span class="ansi32">    edgeflow={}</span>
<span class="ansi32">+</span><span class="ansi32">    for (i,j) in e.keys() :</span>
<span class="ansi32">+</span><span class="ansi32">        edgeflow[i,j]=0</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">        for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            edgeflow[i,j]=edgeflow[i,j]+ model.getVal(x[i,j,s,t])</span>
<span class="ansi32">+</span><span class="ansi32">        if (edgeflow[i,j]&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">            print('edgeflow({0},{1})={2}'.format(i,j,edgeflow[i,j]))</span>
<span class="ansi32">+</span><span class="ansi32">            #print('edgeUsed({0},{1})={2}',format(i,j,z[i,j]))</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi41">        </span>
<span class="ansi32">+</span><span class="ansi32">    fileName="/topologies/"+filename</span>
<span class="ansi32">+</span><span class="ansi32">    lamb,routeList=caculatemaxConcurrentMFPRoute(fileName,consumerList,producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------maxConcurrentMFP variant lambda is:",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi32">    model=MaxMFP(n, e, d)</span>
<span class="ansi32">+</span><span class="ansi32">    model.hideOutput()</span>
<span class="ansi32">+</span><span class="ansi32">    model.optimize()</span>
<span class="ansi32">+</span><span class="ansi32">    maxFlow=model.getObjVal()</span>
<span class="ansi32">+</span><span class="ansi32">    print "  --------MaxMFP Optimal value: ",maxFlow</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    # show the flow detail if nodes is not too many</span>
<span class="ansi32">+</span><span class="ansi32">    if len(n)&lt;50:</span>
<span class="ansi32">+</span><span class="ansi32">        x,vard=model.data</span>
<span class="ansi32">+</span><span class="ansi32">        for (s,t) in d.keys():</span>
<span class="ansi32">+</span><span class="ansi32">            if(d[s,t]&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">                print('Flow({0},{1})={2}'.format(s,t,model.getVal(vard[s,t])))</span>
<span class="ansi32">+</span><span class="ansi32">                for (i,j) in e.keys():</span>
<span class="ansi32">+</span><span class="ansi32">                    if(model.getVal(x[i,j,s,t])&gt;EPS):</span>
<span class="ansi32">+</span><span class="ansi32">                        print('--------x[{0},{1},{2},{3}]={4}'.format(i,j,s,t,model.getVal(x[i,j,s,t])))</span>
<span class="ansi32">+</span><span class="ansi32">    '''</span>
<span class="ansi32">+</span><span class="ansi41">    </span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=caculatenoCommLinkPairFirst(fileName, consumerList, producerList)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------NoCommLinkMultipathPairFirst lambda value: ",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------NoCommLinkMultipathPairFirst maxThroughput value: ",maxThroughput)</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=caculateKshortest(fileName, consumerList, producerList,10000)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------Flooding lambda value: ",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------Flooding maxThroughput value: ",maxThroughput)</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=caculateKshortest(fileName, consumerList, producerList,1)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------BestRoute lambda value: ",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------BestRoute maxThroughput value: ",maxThroughput)</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=caculateKshortest(fileName, consumerList, producerList,2)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------K-shortest -2 lambda value: ",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------K-shortest -2 maxThroughput value: ",maxThroughput)</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=caculateKshortest(fileName, consumerList, producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------K-shortest -3 lambda value: ",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------K-shortest -3 maxThroughput value: ",maxThroughput)</span>
<span class="ansi32">+</span><span class="ansi32">    maxThroughput,lamb,routeList=caculateKshortestwithRestore(fileName, consumerList, producerList,3)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------K-shortest with Restore -3 lambda value: ",lamb)</span>
<span class="ansi32">+</span><span class="ansi32">    print ("  --------K-shortest with Restore -3 maxThroughput value: ",maxThroughput)</span>
<span class="ansi1">diff --git a/examples/ndn-zhangyu-multipath.cpp b/examples/ndn-zhangyu-multipath.cpp</span>
<span class="ansi1">old mode 100755</span>
<span class="ansi1">new mode 100644</span>
<span class="ansi1">index d3147cf..929721e</span>
<span class="ansi1">--- a/examples/ndn-zhangyu-multipath.cpp</span>
<span class="ansi1">+++ b/examples/ndn-zhangyu-multipath.cpp</span>
<span class="ansi36">@@ -56,7 +56,7 @@</span> int
 main (int argc, char *argv[])
 {
 	bool manualAssign=true;
<span class="ansi31">-	int InterestsPerSec=200;</span>
<span class="ansi32">+</span>	<span class="ansi32">int InterestsPerSec=100;</span>
 	int simulationSpan=5;
 	int TraceSpan=1;
 	int recordsNumber=100;
<span class="ansi36">@@ -97,7 +97,7 @@</span> main (int argc, char *argv[])
 	//生成consumer和producer的节点号动态数组
 	if(manualAssign)	{
 		int tmpConsumer[]={0};
<span class="ansi31">-		int tmpProducer[]={2};</span>
<span class="ansi32">+</span>		<span class="ansi32">int tmpProducer[]={3};</span>
 		consumerNodes.assign(tmpConsumer,tmpConsumer+sizeof(tmpConsumer)/sizeof(int));
 		producerNodes.assign(tmpProducer,tmpProducer+sizeof(tmpConsumer)/sizeof(int));
 	}
<span class="ansi36">@@ -109,6 +109,12 @@</span> main (int argc, char *argv[])
 	}
 
 	//根据上面生成的节点对编号装载应用
<span class="ansi32">+</span>	<span class="ansi32">//2020-11-6，为了以后改代码更容易，定义prefix变量，</span>
<span class="ansi32">+</span>	<span class="ansi32">//而不再直接使用/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i])或者producerNode[i]</span>
<span class="ansi32">+</span>	<span class="ansi32">std::vector&lt;string&gt; prefixVar;</span>
<span class="ansi32">+</span>	<span class="ansi32">for(uint32_t i=0;i&lt;producerNodes.size();i++)	{</span>
<span class="ansi32">+</span>		<span class="ansi32">prefixVar.push_back("/Node"+boost::lexical_cast&lt;std::string&gt; (producerNodes[i]));</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
 	for(uint32_t i=0;i&lt;consumerNodes.size();i++)	{
 		ndn::AppHelper consumerHelper ("ns3::ndn::ConsumerCbr");
 		consumerHelper.SetAttribute("Frequency", StringValue (boost::lexical_cast&lt;std::string&gt;(InterestsPerSec)));        // 100 interests a second
<span class="ansi36">@@ -121,25 +127,25 @@</span> main (int argc, char *argv[])
 		consumerHelper.SetAttribute("Randomize", StringValue("exponential"));
 
 		Ptr&lt;Node&gt; consumer1 = Names::Find&lt;Node&gt; ("Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]));
<span class="ansi31">-		consumerHelper.SetPrefix ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerHelper.SetPrefix (prefixVar[i]);</span>
 		ApplicationContainer app=consumerHelper.Install(consumer1);
 		app.Start(Seconds(0.01*i));
 		// Choosing forwarding strategy
<span class="ansi31">-		ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/randomized-rounding");</span>
<span class="ansi32">+</span>		<span class="ansi32">ndn::StrategyChoiceHelper::InstallAll((ndn::Name)prefixVar[i], "/localhost/nfd/strategy/randomized-rounding");</span>
 		//ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/best-route");
 		//ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/ncc");
 
<span class="ansi31">-		std::cout &lt;&lt;"ZhangYu  consumer1-&gt;GetId(): " &lt;&lt;consumer1-&gt;GetId() &lt;&lt; "  prefix: /Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]) &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>		<span class="ansi32">std::cout &lt;&lt;"ZhangYu  consumer1-&gt;GetId(): " &lt;&lt;consumer1-&gt;GetId() &lt;&lt; "  prefix: "+prefixVar[i] &lt;&lt; std::endl;</span>
 	}
 
 	for(uint32_t i=0;i&lt;producerNodes.size();i++)	{
 		ndn::AppHelper producerHelper ("ns3::ndn::Producer");
 		producerHelper.SetAttribute ("PayloadSize", StringValue("1024"));
 		//认为producer节点的Prefix和对应位置的consumer节点一致
<span class="ansi31">-		producerHelper.SetPrefix ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">producerHelper.SetPrefix (prefixVar[i]);</span>
 
 		Ptr&lt;Node&gt; producer1 = Names::Find&lt;Node&gt; ("Node"+boost::lexical_cast&lt;std::string&gt; (producerNodes[i]));
<span class="ansi31">-		ndnGlobalRoutingHelper.AddOrigins ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]), producer1);</span>
<span class="ansi32">+</span>		<span class="ansi32">ndnGlobalRoutingHelper.AddOrigins (prefixVar[i], producer1);</span>
 		producerHelper.Install(producer1);
 		std::cout &lt;&lt;"ZhangYu producer1-&gt;GetId(): " &lt;&lt;producer1-&gt;GetId() &lt;&lt; std::endl;
 	}
<span class="ansi36">@@ -150,9 +156,9 @@</span> main (int argc, char *argv[])
 	}
 	else if(routingName.compare("debug")==0){
 		//当Consumer是0时，prefix=/Node0时，需要添加 0--&gt;1--&gt;4 的路由才可以，添加反向4-&gt;1-&gt;0没有Traffic
<span class="ansi31">-		ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node2",1,0.9);</span>
<span class="ansi31">-		ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node3",1,0.1);</span>
<span class="ansi31">-		ndn::GlobalRoutingHelper::addRouteHop("Node3","/Node0","Node2",1,1.0);</span>
<span class="ansi32">+</span>		<span class="ansi32">ndn::GlobalRoutingHelper::addRouteHop("Node0",prefixVar[0],"Node3",1,1.0);</span>
<span class="ansi32">+</span>		<span class="ansi32">//ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node2",1,0.5);</span>
<span class="ansi32">+</span>		<span class="ansi32">//ndn::GlobalRoutingHelper::addRouteHop("Node2","/Node0","Node3",1,1.0);</span>
 	}
 	else if(routingName.compare("Flooding")==0){
 		ndn::GlobalRoutingHelper::CalculateAllPossibleRoutes();
<span class="ansi1">diff --git a/examples/zhangyu-learning.cpp b/examples/zhangyu-learning.cpp</span>
<span class="ansi1">new file mode 100644</span>
<span class="ansi1">index 0000000..266473c</span>
<span class="ansi1">--- /dev/null</span>
<span class="ansi1">+++ b/examples/zhangyu-learning.cpp</span>
<span class="ansi36">@@ -0,0 +1,459 @@</span>
<span class="ansi32">+</span><span class="ansi32">/* -*-  张宇，ns3和opengym联合仿真。 -*-</span>
<span class="ansi32">+</span><span class="ansi32"> * 借鉴思路，利用ZMQ实现ns3反向调用python的代码，重新实现原来的python调用ns3</span>
<span class="ansi32">+</span><span class="ansi32"> * 合并了原来的ndnSIM-multipath和opengym 2020-8-27</span>
<span class="ansi32">+</span><span class="ansi32"> *</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/core-module.h"</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/opengym-module.h"</span>
<span class="ansi32">+</span><span class="ansi32">// for ns3 default</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/network-module.h"</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/point-to-point-module.h"</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/point-to-point-layout-module.h"</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/ndnSIM-module.h"</span>
<span class="ansi32">+</span><span class="ansi32">//</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/names.h"</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/string.h"</span>
<span class="ansi32">+</span><span class="ansi32">#include "ns3/ptr.h"</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">//#include "q-learning-forwarding/learning-strategy.hpp"</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">using namespace ns3;</span>
<span class="ansi32">+</span><span class="ansi32">using namespace std;</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">NS_LOG_COMPONENT_DEFINE ("OpenGym");</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">Define observation space</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">Ptr&lt;OpenGymSpace&gt; MyGetObservationSpace(void)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span><span class="ansi32">  uint32_t nodeNum = 5;</span>
<span class="ansi32">+</span><span class="ansi32">  float low = 0.0;</span>
<span class="ansi32">+</span><span class="ansi32">  float high = 10.0;</span>
<span class="ansi32">+</span><span class="ansi32">  std::vector&lt;uint32_t&gt; shape = {nodeNum,};</span>
<span class="ansi32">+</span><span class="ansi32">  std::string dtype = TypeNameGet&lt;uint32_t&gt; ();</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymBoxSpace&gt; space = CreateObject&lt;OpenGymBoxSpace&gt; (low, high, shape, dtype);</span>
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_UNCOND ("MyGetObservationSpace: " &lt;&lt; space);</span>
<span class="ansi32">+</span><span class="ansi32">  return space;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">Define action space</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span><span class="ansi32">Ptr&lt;OpenGymSpace&gt; MyGetActionSpace(void)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span><span class="ansi32">  uint32_t nodeNum = 5;</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymDiscreteSpace&gt; space = CreateObject&lt;OpenGymDiscreteSpace&gt; (nodeNum);</span>
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_UNCOND ("MyGetActionSpace: " &lt;&lt; space);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  //ZhangYu dataType</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymDiscreteSpace&gt; discrete = CreateObject&lt;OpenGymDiscreteSpace&gt; (nodeNum);</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymDictSpace&gt; zyspace = CreateObject&lt;OpenGymDictSpace&gt; ();</span>
<span class="ansi32">+</span><span class="ansi32">  zyspace-&gt;Add("node1 to node2", discrete);</span>
<span class="ansi32">+</span><span class="ansi32">  zyspace-&gt;Add("node2 to node3", discrete);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymDiscreteContainer&gt; discreteCt = CreateObject&lt;OpenGymDiscreteContainer&gt;(nodeNum);</span>
<span class="ansi32">+</span><span class="ansi32">  discreteCt-&gt;SetValue(10);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymTupleContainer&gt; data = CreateObject&lt;OpenGymTupleContainer&gt; ();</span>
<span class="ansi32">+</span><span class="ansi32">  data-&gt;Add(discreteCt);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  return zyspace;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">Define game over condition</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span><span class="ansi32">bool MyGetGameOver(void)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  bool isGameOver = false;</span>
<span class="ansi32">+</span><span class="ansi32">  bool test = false;</span>
<span class="ansi32">+</span><span class="ansi32">  static float stepCounter = 0.0;</span>
<span class="ansi32">+</span><span class="ansi32">  stepCounter += 1;</span>
<span class="ansi32">+</span><span class="ansi32">  if (stepCounter == 10 &amp;&amp; test) {</span>
<span class="ansi32">+</span><span class="ansi32">      isGameOver = true;</span>
<span class="ansi32">+</span><span class="ansi32">  }</span>
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_UNCOND ("MyGetGameOver: " &lt;&lt; isGameOver);</span>
<span class="ansi32">+</span><span class="ansi32">  return isGameOver;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">Collect observations</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span><span class="ansi32">Ptr&lt;OpenGymDataContainer&gt; MyGetObservation(void)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span><span class="ansi32">  uint32_t nodeNum = 5;</span>
<span class="ansi32">+</span><span class="ansi32">  uint32_t low = 0.0;</span>
<span class="ansi32">+</span><span class="ansi32">  uint32_t high = 10.0;</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;UniformRandomVariable&gt; rngInt = CreateObject&lt;UniformRandomVariable&gt; ();</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  std::vector&lt;uint32_t&gt; shape = {nodeNum,};</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymBoxContainer&lt;uint32_t&gt; &gt; box = CreateObject&lt;OpenGymBoxContainer&lt;uint32_t&gt; &gt;(shape);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  // generate random data</span>
<span class="ansi32">+</span><span class="ansi32">  for (uint32_t i = 0; i&lt;nodeNum; i++){</span>
<span class="ansi32">+</span><span class="ansi32">    uint32_t value = rngInt-&gt;GetInteger(low, high);</span>
<span class="ansi32">+</span><span class="ansi32">    box-&gt;AddValue(value);</span>
<span class="ansi32">+</span><span class="ansi32">  }</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_UNCOND ("MyGetObservation: " &lt;&lt; box);</span>
<span class="ansi32">+</span><span class="ansi32">  return box;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">Define reward function</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span><span class="ansi32">float MyGetReward(void)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span><span class="ansi32">  static float reward = 0.0;</span>
<span class="ansi32">+</span><span class="ansi32">  reward += 1;</span>
<span class="ansi32">+</span><span class="ansi32">  return reward;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">Define extra info. Optional</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span><span class="ansi32">std::string MyGetExtraInfo(void)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span><span class="ansi32">  std::string myInfo = "testInfo";</span>
<span class="ansi32">+</span><span class="ansi32">  myInfo += "|123";</span>
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_UNCOND("MyGetExtraInfo: " &lt;&lt; myInfo);</span>
<span class="ansi32">+</span><span class="ansi32">  return myInfo;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">Execute received actions</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span><span class="ansi32">bool MyExecuteActions(Ptr&lt;OpenGymDataContainer&gt; action)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span><span class="ansi32">  Ptr&lt;OpenGymDiscreteContainer&gt; discrete = DynamicCast&lt;OpenGymDiscreteContainer&gt;(action);</span>
<span class="ansi32">+</span><span class="ansi32">  NS_LOG_UNCOND ("MyExecuteActions: " &lt;&lt; action);</span>
<span class="ansi32">+</span><span class="ansi32">  return true;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">void ScheduleNextStateRead(double envStepTime, Ptr&lt;OpenGymInterface&gt; openGym)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span><span class="ansi32">  Simulator::Schedule (Seconds(envStepTime), &amp;ScheduleNextStateRead, envStepTime, openGym);</span>
<span class="ansi32">+</span><span class="ansi32">  openGym-&gt;NotifyCurrentState();</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">ZhangYu 2020-8-27</span>
<span class="ansi32">+</span><span class="ansi32">All the parameters for the Network Simulation</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">void networksConfiguration(bool manualAssign,int InterestsPerSec,int simulationSpan,int TraceSpan,int recordsNumber,string routingName)</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------仿真拓扑----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">AnnotatedTopologyReader topologyReader ("", 20);</span>
<span class="ansi32">+</span>	<span class="ansi32">// current directory is build, same as include</span>
<span class="ansi32">+</span>	<span class="ansi32">topologyReader.SetFileName ("src/ndnSIM/examples/topologies/topo-for-CompareMultiPath.txt");</span>
<span class="ansi32">+</span>	<span class="ansi32">// 如果把topologies copy to scratch, then simple_test.py will be stuck, because topologies folder was copied to build</span>
<span class="ansi32">+</span>	<span class="ansi32">topologyReader.Read ();</span>
<span class="ansi32">+</span>	<span class="ansi32">int nodesNumber=topologyReader.GetNodes().size();</span>
<span class="ansi32">+</span>	<span class="ansi32">const NodeContainer&amp; allNodes=topologyReader.GetNodes();</span>
<span class="ansi32">+</span>	<span class="ansi32">for (const auto&amp; n : allNodes) {</span>
<span class="ansi32">+</span>		<span class="ansi32">std::cout &lt;&lt; Names::FindName(n) &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>	<span class="ansi32">std::list&lt;TopologyReader::Link&gt; allLinks=topologyReader.GetLinks();</span>
<span class="ansi32">+</span>	<span class="ansi32">for (TopologyReader::ConstLinksIterator iter=allLinks.begin(); iter!=allLinks.end(); iter++) {</span>
<span class="ansi32">+</span>		<span class="ansi32">std::cout &lt;&lt; "FromNode:"&lt;&lt; iter-&gt;GetFromNode()-&gt;GetId() &lt;&lt; " FromNodeName:" &lt;&lt; iter-&gt;GetFromNodeName() &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------安装Install CCNx stack ----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::StackHelper ndnHelper;</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnHelper.setPolicy("nfd::cs::lru");</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnHelper.setCsSize(1);</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnHelper.InstallAll();</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">topologyReader.ApplyOspfMetric();  //使得链路metric生效</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------Installing global routing interface on all nodes ----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnGlobalRoutingHelper.InstallAll ();</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------设置节点的业务 ----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">//根据不同的拓扑手工指定或者自动生成业务节点对</span>
<span class="ansi32">+</span>	<span class="ansi32">std::vector&lt;int&gt; consumerNodes,producerNodes;</span>
<span class="ansi32">+</span>	<span class="ansi32">//生成consumer和producer的节点号动态数组</span>
<span class="ansi32">+</span>	<span class="ansi32">int tmpConsumer[]={0};</span>
<span class="ansi32">+</span>	<span class="ansi32">int tmpProducer[]={3};</span>
<span class="ansi32">+</span>	<span class="ansi32">consumerNodes.assign(tmpConsumer,tmpConsumer+sizeof(tmpConsumer)/sizeof(int));</span>
<span class="ansi32">+</span>	<span class="ansi32">producerNodes.assign(tmpProducer,tmpProducer+sizeof(tmpConsumer)/sizeof(int));</span>
<span class="ansi32">+</span>	<span class="ansi32">//根据上面生成的节点对编号装载应用</span>
<span class="ansi32">+</span>	<span class="ansi32">for (uint32_t i = 0; i &lt; consumerNodes.size(); i++) {</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::AppHelper consumerHelper ("ns3::ndn::ConsumerCbr");</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerHelper.SetAttribute("Frequency", StringValue (boost::lexical_cast&lt;std::string&gt;(InterestsPerSec)));</span>
<span class="ansi32">+</span>		<span class="ansi32">//ndn::AppHelper consumerHelper("ns3::ndn::ConsumerZipfMandelbrot");</span>
<span class="ansi32">+</span>		<span class="ansi32">//consumerHelper.SetAttribute("NumberOfContents", StringValue("100")); // 10 different contents</span>
<span class="ansi32">+</span>		<span class="ansi32">//可以选择的有：</span>
<span class="ansi32">+</span>		<span class="ansi32">//"none": no randomization</span>
<span class="ansi32">+</span>		<span class="ansi32">//"uniform": uniform distribution in range (0, 1/Frequency)</span>
<span class="ansi32">+</span>		<span class="ansi32">//"exponential": exponential distribution with mean 1/Frequency</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerHelper.SetAttribute("Randomize", StringValue("exponential"));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>		<span class="ansi32">Ptr&lt;Node&gt; consumer1 = Names::Find&lt;Node&gt; ("Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerHelper.SetPrefix ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">ApplicationContainer app=consumerHelper.Install(consumer1);</span>
<span class="ansi32">+</span>		<span class="ansi32">app.Start(Seconds(0.01*i));</span>
<span class="ansi32">+</span>		<span class="ansi32">// Choosing forwarding strategy</span><span class="ansi41"> </span>
<span class="ansi32">+</span>		<span class="ansi32">//</span>
<span class="ansi32">+</span>		<span class="ansi32">// ***************!!!!!!!要特别注意，这里的转发策略名字写错了，不会报错，还可以以默认的转发策略执行</span>
<span class="ansi32">+</span>		<span class="ansi32">//</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/learning");</span>
<span class="ansi32">+</span>		<span class="ansi32">//ns3::ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/randomized-rounding");</span>
<span class="ansi32">+</span>		<span class="ansi32">//ns3::ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/best-route");</span>
<span class="ansi32">+</span>		<span class="ansi32">//ns3::ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/ncc");</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>		<span class="ansi32">NS_LOG_UNCOND ("ZhangYu  consumer1-&gt;GetId(): " &lt;&lt; consumer1-&gt;GetId() &lt;&lt; "  prefix: /Node" &lt;&lt;boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]));</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">for(uint32_t i=0;i&lt;producerNodes.size();i++)	{</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::AppHelper producerHelper ("ns3::ndn::Producer");</span>
<span class="ansi32">+</span>		<span class="ansi32">producerHelper.SetAttribute ("PayloadSize", StringValue("1024"));</span>
<span class="ansi32">+</span>		<span class="ansi32">//认为producer节点的Prefix和对应位置的consumer节点一致</span>
<span class="ansi32">+</span>		<span class="ansi32">producerHelper.SetPrefix ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>		<span class="ansi32">Ptr&lt;Node&gt; producer1 = Names::Find&lt;Node&gt; ("Node"+boost::lexical_cast&lt;std::string&gt; (producerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">ndnGlobalRoutingHelper.AddOrigins ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]), producer1);</span>
<span class="ansi32">+</span>		<span class="ansi32">producerHelper.Install(producer1);</span>
<span class="ansi32">+</span>		<span class="ansi32">NS_LOG_UNCOND ("ZhangYu producer1-&gt;GetId(): " &lt;&lt;producer1-&gt;GetId());</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">// Calculate and install FIBs</span>
<span class="ansi32">+</span>	<span class="ansi32">if(routingName.compare("BestRoute")==0){</span>
<span class="ansi32">+</span>	<span class="ansi32">  ns3::ndn::GlobalRoutingHelper::CalculateRoutes ();</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>	<span class="ansi32">else if(routingName.compare("Learning")==0){</span>
<span class="ansi32">+</span>			<span class="ansi32">ns3::ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node3",1,0.5);</span>
<span class="ansi32">+</span>			<span class="ansi32">ns3::ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node2",1,0.5);</span>
<span class="ansi32">+</span>			<span class="ansi32">ns3::ndn::GlobalRoutingHelper::addRouteHop("Node2","/Node0","Node3",1,1.0);</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span><span class="ansi41">	</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------Tracer 仿真结果 ----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">//ZhangYu Add the trace，不愿意文件名称还有大小写的区别，所以把 routingName 全部转为小写</span>
<span class="ansi32">+</span>	<span class="ansi32">std::transform(routingName.begin(), routingName.end(), routingName.begin(), ::tolower);</span>
<span class="ansi32">+</span>	<span class="ansi32">string filename="-"+routingName+"-"+boost::lexical_cast&lt;std::string&gt;(InterestsPerSec)+".txt";</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">TraceSpan=simulationSpan/recordsNumber;</span>
<span class="ansi32">+</span>	<span class="ansi32">if(TraceSpan&lt;1)</span>
<span class="ansi32">+</span>		<span class="ansi32">TraceSpan=1;</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::CsTracer::InstallAll ("Results/cs-trace"+filename, Seconds (TraceSpan));</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::L3RateTracer::InstallAll ("Results/rate-trace"+filename, Seconds (TraceSpan));</span>
<span class="ansi32">+</span>	<span class="ansi32">// L3AggregateTracer disappeared in new version</span>
<span class="ansi32">+</span>	<span class="ansi32">//ndn::L3AggregateTracer::InstallAll ("aggregate-trace-"+filename, Seconds (1));</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::AppDelayTracer::InstallAll ("Results/app-delays-trace"+filename);</span>
<span class="ansi32">+</span>	<span class="ansi32">L2RateTracer::InstallAll ("Results/drop-trace"+filename, Seconds (TraceSpan));</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">int</span>
<span class="ansi32">+</span><span class="ansi32">main (int argc, char *argv[])</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span>	<span class="ansi32">bool manualAssign=true;</span>
<span class="ansi32">+</span>	<span class="ansi32">int InterestsPerSec=200;</span>
<span class="ansi32">+</span>	<span class="ansi32">int simulationSpan=5;</span>
<span class="ansi32">+</span>	<span class="ansi32">int TraceSpan=1;</span>
<span class="ansi32">+</span>	<span class="ansi32">int recordsNumber=100;</span>
<span class="ansi32">+</span>	<span class="ansi32">string routingName="Learning";</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">// Parameters of the scenario</span>
<span class="ansi32">+</span>	<span class="ansi32">uint32_t simSeed = 1;</span>
<span class="ansi32">+</span>	<span class="ansi32">double simulationTime = 10; //seconds</span>
<span class="ansi32">+</span>	<span class="ansi32">double envStepTime = 0.1; //seconds, ns3gym env step time interval</span>
<span class="ansi32">+</span>	<span class="ansi32">uint32_t openGymPort = 5555;</span>
<span class="ansi32">+</span>	<span class="ansi32">uint32_t testArg = 0;</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">// 这里的参数是在 start_sim.py中传给的</span>
<span class="ansi32">+</span>	<span class="ansi32">CommandLine cmd;</span>
<span class="ansi32">+</span>	<span class="ansi32">// required parameters for OpenGym interface</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("openGymPort", "Port number for OpenGym env. Default: 5555", openGymPort);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("simSeed", "Seed for random generator. Default: 1", simSeed);</span>
<span class="ansi32">+</span>	<span class="ansi32">// optional parameters</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("simTime", "Simulation time in seconds. Default: 10s", simulationTime);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("testArg", "Extra simulation argument. Default: 0", testArg);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">// 19年仿真版本带过来的参数</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue("InterestsPerSec","Interests emit by consumer per second",InterestsPerSec);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue("simulationSpan","Simulation span time by seconds",simulationSpan);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("routingName", "could be Flooding, BestRoute, k-shortest, MultiPathPairFirst, debug", routingName);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("recordsNumber", "total number of records in tracer file", recordsNumber);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.Parse (argc, argv);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND("Ns3Env parameters:");</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND("--simulationTime: " &lt;&lt; simulationTime);</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND("--openGymPort: " &lt;&lt; openGymPort);</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND("--envStepTime: " &lt;&lt; envStepTime);</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND("--seed: " &lt;&lt; simSeed);</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND("--testArg: " &lt;&lt; testArg);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">RngSeedManager::SetSeed (1);</span>
<span class="ansi32">+</span>	<span class="ansi32">RngSeedManager::SetRun (simSeed);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">networksConfiguration(manualAssign,InterestsPerSec,simulationSpan,TraceSpan,recordsNumber,routingName);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">// OpenGym Env</span>
<span class="ansi32">+</span>	<span class="ansi32">Ptr&lt;OpenGymInterface&gt; openGym = CreateObject&lt;OpenGymInterface&gt; (openGymPort);</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;SetGetActionSpaceCb( MakeCallback (&amp;MyGetActionSpace) );</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;SetGetObservationSpaceCb( MakeCallback (&amp;MyGetObservationSpace) );</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;SetGetGameOverCb( MakeCallback (&amp;MyGetGameOver) );</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;SetGetObservationCb( MakeCallback (&amp;MyGetObservation) );</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;SetGetRewardCb( MakeCallback (&amp;MyGetReward) );</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;SetGetExtraInfoCb( MakeCallback (&amp;MyGetExtraInfo) );</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;SetExecuteActionsCb( MakeCallback (&amp;MyExecuteActions) );</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//Simulator::Schedule (Seconds(0.0), &amp;ScheduleNextStateRead, envStepTime, openGym);</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND ("Simulation start");</span>
<span class="ansi32">+</span>	<span class="ansi32">Simulator::Stop (Seconds (simulationTime));</span>
<span class="ansi32">+</span>	<span class="ansi32">Simulator::Run ();</span>
<span class="ansi32">+</span>	<span class="ansi32">NS_LOG_UNCOND ("Simulation stop");</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">openGym-&gt;NotifySimulationEnd();</span>
<span class="ansi32">+</span>	<span class="ansi32">Simulator::Destroy ();</span>
<span class="ansi32">+</span>	<span class="ansi32">return 0;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">/*</span>
<span class="ansi32">+</span><span class="ansi32">int</span>
<span class="ansi32">+</span><span class="ansi32">main (int argc, char *argv[])</span>
<span class="ansi32">+</span><span class="ansi32">{</span>
<span class="ansi32">+</span>	<span class="ansi32">bool manualAssign=true;</span>
<span class="ansi32">+</span>	<span class="ansi32">int InterestsPerSec=200;</span>
<span class="ansi32">+</span>	<span class="ansi32">int simulationSpan=5;</span>
<span class="ansi32">+</span>	<span class="ansi32">int TraceSpan=1;</span>
<span class="ansi32">+</span>	<span class="ansi32">int recordsNumber=100;</span>
<span class="ansi32">+</span>	<span class="ansi32">string routingName="debug";</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------命令行参数----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">CommandLine cmd;</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue("InterestsPerSec","Interests emit by consumer per second",InterestsPerSec);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue("simulationSpan","Simulation span time by seconds",simulationSpan);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("routingName", "could be Flooding, BestRoute, k-shortest, MultiPathPairFirst, debug", routingName);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.AddValue ("recordsNumber", "total number of records in tracer file", recordsNumber);</span>
<span class="ansi32">+</span>	<span class="ansi32">cmd.Parse(argc,argv);</span>
<span class="ansi32">+</span>	<span class="ansi32">//std::cout &lt;&lt; "routingName: " &lt;&lt; routingName &lt;&lt; "   " &lt;&lt; InterestsPerSec &lt;&lt; " " &lt;&lt; simulationSpan &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------仿真拓扑----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">AnnotatedTopologyReader topologyReader ("", 20);</span>
<span class="ansi32">+</span>	<span class="ansi32">//topologyReader.SetFileName ("src/ndnSIM/examples/topologies/26node-result.txt");</span>
<span class="ansi32">+</span>	<span class="ansi32">topologyReader.SetFileName ("src/ndnSIM/examples/topologies/topo-for-CompareMultiPath.txt");</span>
<span class="ansi32">+</span>	<span class="ansi32">topologyReader.Read ();</span>
<span class="ansi32">+</span>	<span class="ansi32">int nodesNumber=topologyReader.GetNodes().size();</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------安装Install CCNx stack ----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::StackHelper ndnHelper;</span>
<span class="ansi32">+</span>	<span class="ansi32">// 下面这一句是Install NDN stack on all nodes</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnHelper.setPolicy("nfd::cs::lru");</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnHelper.setCsSize(1);</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnHelper.InstallAll();</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">topologyReader.ApplyOspfMetric();  //使得链路metric生效</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------Installing global routing interface on all nodes ----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;</span>
<span class="ansi32">+</span>	<span class="ansi32">ndnGlobalRoutingHelper.InstallAll ();</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//----------------设置节点的业务 ----------------</span>
<span class="ansi32">+</span>	<span class="ansi32">//根据不同的拓扑手工指定或者自动生成业务节点对</span>
<span class="ansi32">+</span>	<span class="ansi32">std::vector&lt;int&gt; consumerNodes,producerNodes;</span>
<span class="ansi32">+</span>	<span class="ansi32">//生成consumer和producer的节点号动态数组</span>
<span class="ansi32">+</span>	<span class="ansi32">if(manualAssign)	{</span>
<span class="ansi32">+</span>		<span class="ansi32">int tmpConsumer[]={0};</span>
<span class="ansi32">+</span>		<span class="ansi32">int tmpProducer[]={3};</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerNodes.assign(tmpConsumer,tmpConsumer+sizeof(tmpConsumer)/sizeof(int));</span>
<span class="ansi32">+</span>		<span class="ansi32">producerNodes.assign(tmpProducer,tmpProducer+sizeof(tmpConsumer)/sizeof(int));</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>	<span class="ansi32">else	{</span>
<span class="ansi32">+</span>		<span class="ansi32">for(int i=0;i&lt;nodesNumber/2;i++)	{</span>
<span class="ansi32">+</span>		<span class="ansi32">  consumerNodes.push_back(i);</span>
<span class="ansi32">+</span>		<span class="ansi32">  producerNodes.push_back(i+nodesNumber/2);</span>
<span class="ansi32">+</span>		<span class="ansi32">}</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//根据上面生成的节点对编号装载应用</span>
<span class="ansi32">+</span>	<span class="ansi32">for(uint32_t i=0;i&lt;consumerNodes.size();i++)	{</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::AppHelper consumerHelper ("ns3::ndn::ConsumerCbr");</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerHelper.SetAttribute("Frequency", StringValue (boost::lexical_cast&lt;std::string&gt;(InterestsPerSec)));        // 100 interests a second</span>
<span class="ansi32">+</span>		<span class="ansi32">//ndn::AppHelper consumerHelper("ns3::ndn::ConsumerZipfMandelbrot");</span>
<span class="ansi32">+</span>		<span class="ansi32">//consumerHelper.SetAttribute("NumberOfContents", StringValue("100")); // 10 different contents</span>
<span class="ansi32">+</span>		<span class="ansi32">//可以选择的有：</span>
<span class="ansi32">+</span>		<span class="ansi32">//"none": no randomization</span>
<span class="ansi32">+</span>		<span class="ansi32">//"uniform": uniform distribution in range (0, 1/Frequency)</span>
<span class="ansi32">+</span>		<span class="ansi32">//"exponential": exponential distribution with mean 1/Frequency</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerHelper.SetAttribute("Randomize", StringValue("exponential"));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>		<span class="ansi32">Ptr&lt;Node&gt; consumer1 = Names::Find&lt;Node&gt; ("Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">consumerHelper.SetPrefix ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">ApplicationContainer app=consumerHelper.Install(consumer1);</span>
<span class="ansi32">+</span>		<span class="ansi32">app.Start(Seconds(0.01*i));</span>
<span class="ansi32">+</span>		<span class="ansi32">// Choosing forwarding strategy</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/randomized-rounding");</span>
<span class="ansi32">+</span>		<span class="ansi32">//ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/best-route");</span>
<span class="ansi32">+</span>		<span class="ansi32">//ndn::StrategyChoiceHelper::InstallAll("/Node"+boost::lexical_cast&lt;std::string&gt; (consumerNodes[i]), "/localhost/nfd/strategy/ncc");</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>		<span class="ansi32">std::cout &lt;&lt;"ZhangYu  consumer1-&gt;GetId(): " &lt;&lt;consumer1-&gt;GetId() &lt;&lt; "  prefix: /Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]) &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">for(uint32_t i=0;i&lt;producerNodes.size();i++)	{</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::AppHelper producerHelper ("ns3::ndn::Producer");</span>
<span class="ansi32">+</span>		<span class="ansi32">producerHelper.SetAttribute ("PayloadSize", StringValue("1024"));</span>
<span class="ansi32">+</span>		<span class="ansi32">//认为producer节点的Prefix和对应位置的consumer节点一致</span>
<span class="ansi32">+</span>		<span class="ansi32">producerHelper.SetPrefix ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>		<span class="ansi32">Ptr&lt;Node&gt; producer1 = Names::Find&lt;Node&gt; ("Node"+boost::lexical_cast&lt;std::string&gt; (producerNodes[i]));</span>
<span class="ansi32">+</span>		<span class="ansi32">ndnGlobalRoutingHelper.AddOrigins ("/Node"+boost::lexical_cast&lt;std::string&gt;(consumerNodes[i]), producer1);</span>
<span class="ansi32">+</span>		<span class="ansi32">producerHelper.Install(producer1);</span>
<span class="ansi32">+</span>		<span class="ansi32">std::cout &lt;&lt;"ZhangYu producer1-&gt;GetId(): " &lt;&lt;producer1-&gt;GetId() &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">// Calculate and install FIBs</span>
<span class="ansi32">+</span>	<span class="ansi32">if(routingName.compare("BestRoute")==0){</span>
<span class="ansi32">+</span>	<span class="ansi32">  ns3::ndn::GlobalRoutingHelper::CalculateRoutes ();</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>	<span class="ansi32">else if(routingName.compare("debug")==0){</span>
<span class="ansi32">+</span>		<span class="ansi32">//当Consumer是0时，prefix=/Node0时，需要添加 0--&gt;1--&gt;4 的路由才可以，添加反向4-&gt;1-&gt;0没有Traffic</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node3",1,0.5);</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::GlobalRoutingHelper::addRouteHop("Node0","/Node0","Node2",1,0.5);</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::GlobalRoutingHelper::addRouteHop("Node2","/Node0","Node3",1,1.0);</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>	<span class="ansi32">else if(routingName.compare("Flooding")==0){</span>
<span class="ansi32">+</span>		<span class="ansi32">ns3::ndn::GlobalRoutingHelper::CalculateAllPossibleRoutes();</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>	<span class="ansi32">else{</span>
<span class="ansi32">+</span>		<span class="ansi32">std::cout &lt;&lt; "!!!!  ~~~~~~Unkown routingName: " &lt;&lt; routingName &lt;&lt; ", try again..." &lt;&lt;std::endl;</span>
<span class="ansi32">+</span>	<span class="ansi32">}</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">// The failure of the link connecting consumer and router will start from seconds 10.0 to 15.0</span>
<span class="ansi32">+</span>	<span class="ansi32">//Simulator::Schedule (Seconds (10.0), ndn::LinkControlHelper::FailLink, Names::Find&lt;Node&gt; ("Node0"),Names::Find&lt;Node&gt; ("Node4"));</span>
<span class="ansi32">+</span>	<span class="ansi32">//Simulator::Schedule (Seconds (15.0), ndn::LinkControlHelper::UpLink,   Names::Find&lt;Node&gt; ("Node0"),Names::Find&lt;Node&gt; ("Node4"));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">Simulator::Stop (Seconds(simulationSpan));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">//ZhangYu Add the trace，不愿意文件名称还有大小写的区别，所以把 routingName 全部转为小写</span>
<span class="ansi32">+</span>	<span class="ansi32">std::transform(routingName.begin(), routingName.end(), routingName.begin(), ::tolower);</span>
<span class="ansi32">+</span>	<span class="ansi32">string filename="-"+routingName+"-"+boost::lexical_cast&lt;std::string&gt;(InterestsPerSec)+".txt";</span>
<span class="ansi32">+</span>	<span class="ansi32">//filename=".txt";</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">TraceSpan=simulationSpan/recordsNumber;</span>
<span class="ansi32">+</span>	<span class="ansi32">if(TraceSpan&lt;1)</span>
<span class="ansi32">+</span>		<span class="ansi32">TraceSpan=1;</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::CsTracer::InstallAll ("Results/cs-trace"+filename, Seconds (TraceSpan));</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::L3RateTracer::InstallAll ("Results/rate-trace"+filename, Seconds (TraceSpan));</span>
<span class="ansi32">+</span>	<span class="ansi32">// L3AggregateTracer disappeared in new version</span>
<span class="ansi32">+</span>	<span class="ansi32">//ndn::L3AggregateTracer::InstallAll ("Results/aggregate-trace-"+filename, Seconds (1));</span>
<span class="ansi32">+</span>	<span class="ansi32">ns3::ndn::AppDelayTracer::InstallAll ("Results/app-delays-trace"+filename);</span>
<span class="ansi32">+</span>	<span class="ansi32">L2RateTracer::InstallAll ("Results/drop-trace"+filename, Seconds (TraceSpan));</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span>	<span class="ansi32">Simulator::Run ();</span>
<span class="ansi32">+</span>	<span class="ansi32">Simulator::Destroy ();</span>
<span class="ansi32">+</span>
<span class="ansi32">+</span><span class="ansi32">  return 0;</span>
<span class="ansi32">+</span><span class="ansi32">}</span>
<span class="ansi32">+</span><span class="ansi32">*/</span>
<span class="ansi1">diff --git a/helper/lfid/ndn-global-routing-helper-lfid.cpp b/helper/lfid/ndn-global-routing-helper-lfid.cpp</span>
<span class="ansi1">index 13f86ab..a4d2976 100644</span>
<span class="ansi1">--- a/helper/lfid/ndn-global-routing-helper-lfid.cpp</span>
<span class="ansi1">+++ b/helper/lfid/ndn-global-routing-helper-lfid.cpp</span>
<span class="ansi36">@@ -122,7 +122,7 @@</span> GlobalRoutingHelper::CalculateLfidRoutes()
 
       const auto&amp; face = get&lt;shared_ptr&lt;Face&gt;&gt;(neighbor);
       NS_ABORT_UNLESS(face-&gt;getMetric() == get&lt;uint16_t&gt;(boost::WeightInf));
<span class="ansi31">-      face-&gt;setMetric(originalMetrics.at(nbId));</span>
<span class="ansi32">+</span><span class="ansi32">      (originalMetrics.at(nbId));</span>
     }
 
     // 4. Fill Abstract FIB:
<span class="ansi1">diff --git a/helper/ndn-fib-helper.cpp b/helper/ndn-fib-helper.cpp</span>
<span class="ansi1">index 42cc790..d6a25d4 100644</span>
<span class="ansi1">--- a/helper/ndn-fib-helper.cpp</span>
<span class="ansi1">+++ b/helper/ndn-fib-helper.cpp</span>
<span class="ansi36">@@ -42,6 +42,8 @@</span>
 #include "ns3/ndnSIM/model/ndn-l3-protocol.hpp"
 #include "ns3/ndnSIM/helper/ndn-stack-helper.hpp"
 
<span class="ansi32">+</span><span class="ansi32">using namespace std;</span>
<span class="ansi32">+</span>
 namespace ns3 {
 namespace ndn {
 
<span class="ansi36">@@ -173,7 +175,7 @@</span> FibHelper::AddRoute(const std::string&amp; nodeName, const Name&amp; prefix,
 /* ****************************ZhangYu 2020-8-30 添加 Randomized Rounding******************************
  * ZhangYu 2020-8-30 估计原来是考虑到只是增加了Probability，移除时可以使用Metric的移除直接移除，没有增加Remove
  * ZhangYu 2018-1-31 添加了端口概率，为了方便，将所有调用的函数都排在后面
<span class="ansi31">- * 2018-2-1 在tlv格式中，因为浮点数编码复杂，所有只处理整数类型，因为将probability在数据源头将其变为整数，使用时复原</span>
<span class="ansi32">+</span><span class="ansi32"> * 2018-2-1 在tlv格式中，估计因为浮点数编码复杂，所以只处理整数类型，故将probability在数据源头将其变为整数，使用时复原</span>
  */
 void
 FibHelper::AddRoute(const std::string&amp; nodeName, const Name&amp; prefix,
<span class="ansi36">@@ -232,6 +234,8 @@</span> FibHelper::AddRoute(Ptr&lt;Node&gt; node, const Name&amp; prefix, shared_ptr&lt;Face&gt; face, i
   parameters.setFaceId(face-&gt;getId());
   parameters.setCost(metric);
   parameters.setProbability(probability);
<span class="ansi32">+</span><span class="ansi32">  //std::cout &lt;&lt; "**********ZhangYu 2020-11-6 ndn-fib-helper setProbability: " &lt;&lt; probability &lt;&lt; std::endl;</span>
<span class="ansi32">+</span>
   AddNextHop(parameters, node);
   //ZhangYu 2018-2-1
   //std::cout &lt;&lt;"2018-2-1 FibHelper::AddRoute -- probability:" &lt;&lt; probability &lt;&lt; std::endl;
<span class="ansi1">diff --git a/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp b/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp</span>
<span class="ansi1">index 069e1e7..21a4002 100644</span>
<span class="ansi1">--- a/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp</span>
<span class="ansi1">+++ b/ndn-cxx/ndn-cxx/mgmt/nfd/control-parameters.hpp</span>
<span class="ansi36">@@ -304,6 +304,7 @@</span> public: // getters &amp; setters
   {
     m_wire.reset();
     m_probability = probability;
<span class="ansi32">+</span><span class="ansi32">    //std::cout &lt;&lt; "--------ZhangYu 2020-11-6 control-parameters setProbability: " &lt;&lt; probability &lt;&lt; std::endl;</span>
     m_hasFields[CONTROL_PARAMETER_PROBABILITY] = true;
     return *this;
   }
<span class="ansi36">@@ -675,7 +676,7 @@</span> private: // fields
   std::string         m_localUri;
   RouteOrigin         m_origin;
   uint64_t            m_cost;
<span class="ansi31">-  uint64_t			  m_probability; // ZhangYu 2020-8-30,2018-1-31</span>
<span class="ansi32">+</span><span class="ansi32">  uint64_t			  m_probability=1000; // ZhangYu 2020-8-30,2018-1-31</span>
   uint64_t            m_capacity;
   uint64_t            m_count;
   uint64_t            m_flags;
<span class="ansi1">diff --git a/utils/topology/annotated-topology-reader.cpp b/utils/topology/annotated-topology-reader.cpp</span>
<span class="ansi1">index 3a451de..98c08c2 100644</span>
<span class="ansi1">--- a/utils/topology/annotated-topology-reader.cpp</span>
<span class="ansi1">+++ b/utils/topology/annotated-topology-reader.cpp</span>
<span class="ansi36">@@ -299,7 +299,7 @@</span> AnnotatedTopologyReader::ApplyOspfMetric()
         shared_ptr&lt;ndn::Face&gt; face = ndn-&gt;getFaceByNetDevice(link.GetFromNetDevice());
         NS_ASSERT(face != 0);
 
<span class="ansi31">-        face-&gt;setMetric(metric);</span>
<span class="ansi32">+</span><span class="ansi32">        (metric);</span>
       }
     }
 
<span class="ansi36">@@ -317,7 +317,7 @@</span> AnnotatedTopologyReader::ApplyOspfMetric()
         shared_ptr&lt;ndn::Face&gt; face = ndn-&gt;getFaceByNetDevice(link.GetToNetDevice());
         NS_ASSERT(face != 0);
 
<span class="ansi31">-        face-&gt;setMetric(metric);</span>
<span class="ansi32">+</span><span class="ansi32">        (metric);</span>
       }
     }
   }

</pre>
</body>

</html>
